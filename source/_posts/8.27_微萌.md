---
title: 微萌医院管理
date: 2021-08-27
tags:
---



## 静态代理

描述：通过代理去访问目标对象，代理可以对目标对象的功能进行扩充。



接口类

```java
package com.proxy;

public interface IUserDao {
    public void save();
}
```

目标对象UserDao

```java
package com.proxy;

public class UserDao implements IUserDao{

    @Override
    public void save() {
        System.out.println("保存数据");
    }
}
```

代理

```java
package com.proxy;

public class UserDaoProxy implements IUserDao{

    private IUserDao target;
    public UserDaoProxy(IUserDao target) {
        this.target = target;
    }
    
    @Override
    public void save() {
        System.out.println("开启事务");//扩展了额外功能
        target.save();
        System.out.println("提交事务");
    }
}
```

测试类

```java
package com.proxy;

import org.junit.Test;

public class StaticUserProxy {
    @Test
    public void testStaticProxy(){
        //目标对象
        IUserDao target = new UserDao();
        //代理对象
        IUserDao proxy = new UserDaoProxy(target);
        proxy.save();
    }
}
```



## 动态代理



接口类

```java
package com.proxy;

public interface IUserDao {
    public void save();
}
```

目标对象

```java
package com.proxy;

public class UserDao implements IUserDao{

    @Override
    public void save() {
        System.out.println("保存数据");
    }
}
```



动态代理对象

```java
package com.proxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class ProxyFactory {

    private Object target;// 维护一个目标对象

    public ProxyFactory(Object target) {
        this.target = target;
    }

    // 为目标对象生成代理对象
    public Object getProxyInstance() {
        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),
                new InvocationHandler() {

                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        System.out.println("开启事务");

                        // 执行目标对象方法
                        Object returnValue = method.invoke(target, args);

                        System.out.println("提交事务");
                        return null;
                    }
                });
    }
}
```



测试类

```java
package com.proxy;

import org.junit.Test;

public class TestProxy {

    @Test
    public void testDynamicProxy (){
        IUserDao target = new UserDao();
        System.out.println(target.getClass());  //输出目标对象信息
        IUserDao proxy = (IUserDao) new ProxyFactory(target).getProxyInstance();
        System.out.println(proxy.getClass());  //输出代理对象信息
        proxy.save();  //执行代理方法
    }
}
```





xml装载

缓存 代理 mapper 开启 获取相关xml东西

## vue

### 静态路由



### 动态路由



### vue如何实现页面不刷新

### 如何自己写一个组件

slot

### 父组件如何传值给子组件

ref

:data

## mvc的执行流程



## AOP

切面class





疯狂问代理各种代理%



## linux启动服务 

Centos7 自启动方式 

一 通过（init.d）服务的方式自启动

1.在/etc/init.d 下建立相关程序的启动脚本

ln -s /etc/init.d/服务名 /etc/rc.d/rc3.d/S100服务名 //S:开机自启动 100:启动顺序

2.chkconfig --add 服务名

3.chkconfig 服务名 on 开机自启动

chkconfig 服务名 off 关闭自启动

4.service 服务名 start 手动启动服务

5.service 服务名 stop 手动关闭服务 

二 通过systemctl 服务的方式自启动

1.cd /usr/lib/systemd/system/

2.vi 服务名.service

\# Systemd unit file for default tomcat

\#

\# To create clones of this service:

\# DO NOTHING, use tomcat@.service instead.



## redis锁

## 序列化的多种实现方式

### 实现serializable接口

实现Serializable并且要有serialVersionUID，序列化UID





### 实现Externalizable接口

Externalizable接口继承了Serializable接口

```java
public interface Externalizable extends java.io.Serializable {
    /**
     * The object implements the writeExternal method to save its contents
     * by calling the methods of DataOutput for its primitive values or
```



并且多了两个方法writeExternal和readExternal

```java
@Data
class Person implements Externalizable{
        private static final long serialVersionUID = 1L;<br>    String userName;
    String password;
    String age;
     
   
    public Person(String userName, String password, String age) {
        super();
        this.userName = userName;
        this.password = password;
        this.age = age;
    }
     
     
    public Person() {
        super();
    }
     
    /**
     * 序列化操作的扩展类
     */
    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
        //增加一个新的对象
        Date date=new Date();
        out.writeObject(userName);
        out.writeObject(password);
        out.writeObject(date);
    }
     
    /**
     * 反序列化的扩展类
     */
    @Override
    public void readExternal(ObjectInput in) throws IOException,
            ClassNotFoundException {
        //注意这里的接受顺序是有限制的哦，否则的话会出错的
        // 例如上面先write的是A对象的话，那么下面先接受的也一定是A对象...
        userName=(String) in.readObject();
        password=(String) in.readObject();
        SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd");
        Date date=(Date)in.readObject();       
        System.out.println("反序列化后的日期为:"+sdf.format(date));
         
    }
    @Override
    public String toString() {
        //注意这里的年龄是不会被序列化的，所以在反序列化的时候是读取不到数据的
        return "用户名:"+userName+"密 码:"+password+"年龄:"+age;
    }
}
```

## synchronized和Lock的选择



通过Lock可以通过tryLock获得返回值知道线程是否成功获得了锁，而synchronized不行。

synchronize是JVM层面的，线程异常时JVM会让线程放弃锁，而Lock是JDK层面的，需要手动Lock.unlock()