---
title: 杭州福猫
date: 2021-08-16
tags:
---



# 杭州福猫公司 vue生命周期 数据库范式 事务 



## 前端 element ui

upload组件 action 和url上传方式

![Pasted Graphic](https://tva1.sinaimg.cn/large/008i3skNly1gu2q6mvvb8j610p0u0tc202.jpg)单页面的生命周期hook


![Image](https://tva1.sinaimg.cn/large/008i3skNly1gu2q6u8wgrj30u0140af0.jpg)

## 数据库

### 范式
第一范式是指电话号码不能有手机和电话两种值，强调列的原子性。所以电话号码就应该分为两个原子列 手机电话和固定电话列

第二范式
必须要有主键

第三范式
普通列必须完全依赖主键

第四范式

索引
解决大量多表联查方法：分成多个月，名字的时效性




单例模式

![Pasted Graphic-0598428](https://tva1.sinaimg.cn/large/008i3skNly1gu2q7gf6f0j60qu06amxu02.jpg)

![Pasted Graphic 1-0598435](https://tva1.sinaimg.cn/large/008i3skNly1gu2q7kkc3gj60qu06amxu02.jpg)

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gu2q7oqpepj60io0gmab802.jpg" alt="Pasted Graphic 2" style="zoom:50%;" />

## 事务的特性和spring的事务传播特性
`ACID`
**原子性（Atomicity）**、**一致性（Consistency）**、**隔离性（Isolation）**、**持久性（Durability）**。
**这个是数据库事物的核心**，它是数据库最基本的特性。这条特性看起来简单，但是理解起来还是比较复杂的。

它的书面定义是：数据库**一致性**（Database Consistency）是指事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。
它分为两个方面：**一致读** 和 **一致写**
一致读：事务读取数据只能从一个状态中读取，不能从2个或者2个以上状态读取。
一致写：事务执行的数据变更只能基于上一个一致的状态，且只能体现在一个状态中。
具体解释请认真参看并理解 知乎 如何理解数据库事务中的一致性的概念？徐志斌的回答

### 使用@transactional后如何回滚，传统方式如何回滚
先开启@EnableTransactionManagement，后在Service中@transactional

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gu2q81v79tj60gq03q74i02.jpg" alt="D919BDBF-B512-4D43-B7A6-72BB18D53A05" style="zoom:50%;" />

![E14FF2E5-A383-463B-BFE1-41322BF17C33](https://tva1.sinaimg.cn/large/008i3skNly1gu2q852i6xj61l609ymzd02.jpg)


### 传播行为

默认的事务传播行为是Propagation.REQUIRED，也就是说：如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。
思寒就是用的require

```
@Service 
public class UserService2 { 
	@Autowired private UserService userService; 
	
	@Transactional 
	public void inserBatch() { 
		for (int i = 0; i < 10; i++) { 
			if (i == 9) { 
				throw new RuntimeException(); 
			} 
			userService.insert(); 
		} 
	 } 
}
```
这个函数插入了10次  在第九次有异常 
按理说前面8次应该正常执行,但是并没有 数据库中没有数据
这就是最省事的 一旦整个函数中有异常 就直接回滚
2. supports
如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行。也就是说，该模式是否支持事务，看调用它的方法是否有事务支持。测试代码如下：
UserService
```java
@Transactional(propagation = Propagation.SUPPORTS) 
public void insert() { 
		UserEntity user = new UserEntity(); 
		user.setUsername(“happyjava”); 
		user.setPassword(“123456”); 
		userRepo.save(user); 
		throw new RuntimeException(); 
} 
```

UserService2
```java
public void insertWithoutTx() { 
	userService.insert(); 
}
```
按理说insert是一个事务应该回滚 但是最终没有回滚

## 隔离性
多个事务同时运行 可能会有 脏读 幻读 不可重复读等问题
为了防止
需要将事务隔离
隔离方法有 
1. 默认 
2. 读-未提交: 一个事务A可以读取一个未提交的事务
3. 读-提交
4. 重复读: 读取时 不允许修改
5. 序列化

读-未提交
**Read uncommitted**
读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。
事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。
分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。

那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。


例子读-提交
你拿着银行卡去充游戏 看到有100万 但是你付款时发现没钱了
因为你老婆把你钱那去买钻石了

例子 重复读
你和同学同时去银行取同一张卡的钱

串行化
隔离脏数据 旧数据

持久性（Durability）
就是说任何执行成功的事务修改后的数据都要保证永久的保存在数据库系统中，能够时刻记录系统的状态，并且保证发生故障后能够恢复


## 多线程
四种线程创建方式: Runnable接口, callable接口, futureTask

生命周期: new 就绪 阻塞 运行 Dead

## 异常
举例常用运行时常:IOException,ArrithmeticException,NullPointerException
运行时都是RuntimeException子类 一般由于逻辑引起 可以避免 可以不管它
Throwable祖先 Error Exception子类
Exception等于RuntimeException+非运行时

