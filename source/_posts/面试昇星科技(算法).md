---
title: 昇星科技
date: 2021-08-23
tags:
---



## 选择排序

核心是找到最小值对应的坐标，假设i是最小的

```java
public void selection(Comparable[] arr) {
    int N = arr.length;
    for(int i=0;i<N;i++) {
        int min=i; // 假设i是最小的
        for(int j=i+1;j<N;j++) {
            if(less(arr[j],arr[min])) {
                min=j;
            }
        }
        exch(arr,min,i) // 一轮下来找到了最小的
    }
}
```



## 插入排序

核心是类似抓牌，将新牌插入到有序牌中。

假设0~i是有序的，将i+1插入进去，为了整个数组，引入j

```java
public void sort(Comparable[] arr) {
    int N=arr.length;
    for(int i=1;i<N;i++) {
        for(int j=i;j>0 && less(arr[j],arr[j-1]);j--) { 
            // j不停的往前交换，直到冲不动了，或者冲到了第一名
            exch(arr,j,j-1); 
        }
    }
}
```

因为j-1的存在，所以i从1开始

## 希尔排序

在插入排序的基础上加入一个动态步长。



```java
public void sort(Comparable[] arr) {
    int N=arr.length;
    int h=1;
    while(h<N/3) h=3*h+1; // 1,4,13
    while(h>=1) {
        // 选择排序
        for(int i=h;i<N;i++) {
            for(int j=i;j>=h&&less(arr[j],arr[j-h]);j-=h) {
                exch(arr,j,j-h);
            }
        }
            
        h=h/3;
    }
}
```

因为j-h的存在，所以j>=h，i=h



## 快速排序

核心：切分

切分的核心：把第一个当做参照物，参照物不动，老师指挥两头开始交换，直到中间两个人为止。



```java
public void sort(Comparable[] arr,int low,int high) {
    if(high<=low) return;
    int j=partition(arr,low,high)
    sort(arr,low,j-1);
    sort(arr,j+1,high);
}

public int partition(Comparable[] arr, int low,int high) {
    int i=low,j=high+1;
    while(true) {
        while(less(arr[++i],arr[low])) if(i==high) break;
        while(less(arr[low],arr[--j])) if(j==low) break;
        if(j<=i) return;
        exch(arr,i,j); // 高个和矮个放到合适的位置
    }
    // 最终泾渭分明，i和j对应的身高差不多，选择j作为分割线，将参照物同学放在合适的位置
    exch(arr,low,j);
    return j;
}
```

因为第一个参照物同学不动，所以是++i，--j，j=high+1;



## 二叉排序树



核心：<0，到左子树找，>0，到右子树找；



根据键找值

```java
public Value get(Node node,Key key) {
    if(node==null) return;
    int cmp = key.compareTo(node.val);
    if(cmp<0) return get(node.left,key);
    else if(cmp>0) return get(node.right,key);
    else return node.val;
}
```





```java
public Node put(Node node,Key key) {
    if(node==null) return new Node(key);
    int cmp = key.compareTo(node.key);
    if(cmp<0) 
        node.left = put(node.left,key);
    else if(cmp>0) 
        node.right = put(node.right,key);
    return node;
}
```



