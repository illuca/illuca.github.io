---
title: 全尚科技
date: 2021-08-23
tags:
---

# 面试全尚科技

## Hashmap索引1.7到1.8的变化

头插和尾插

## 对象的四种创建方法

new、反序列化、反射、clone

### **反序列化**

> 将流转化为对象



### **反射**

```
Class c = Class.forName(subClassName);

（1）java.lang.Class.newInstance()

User user = (User)c.newInstance();// 不带参数

（2）java.lang.reflect.Constructor类的newInstance()

Constructor con = c.getConstructor(String.class);

User user = (User) con.newInstance(“name”);
```

第一种只能通过默认构造器构建，而第二种可以用有参构造器。特意拿Constructor 获取构造器 定制

### **clone**

p=new Person("小王","123")

p=p1，他们都指向同一个对象Person("小王","123")

而p1=p.clone()不是，他们指向不同的Person对象 只是拥有相同的属性值



如果Person内部还有引用特殊的引用对象，则需要深度克隆。实现cloneable接口，重写clone方法。

## springmvc的执行流程

![image-20210823211216043](https://tva1.sinaimg.cn/large/008i3skNly1gtr15dtfc3j60c603p3yy02.jpg)



## springmvc 的最重要组件

dispatcherServlet是前端控制器，与前端打交道。



## 容器的核心原理 机制

反射



## 线程池的创建

sheduled、fixed、cached

计划、固定、缓存、单线程

### 单线程

```java
private static void createSingleThreadPool() {
        ExecutorService executorService = Executors.newSingleThreadExecutor();
        for (int i = 0; i < 10; i++) {
            final int index = i;
            executorService.execute(() -> {
                // 获取线程名称,默认格式:pool-1-thread-1
                System.out.println(DateUtil.now() + " " + Thread.currentThread().getName() + " " + index);
                // 等待2秒
                sleep(2000);
            });
        }
    }
```





### 固定

设置总共3个线程

```java
private static void createFixedThreadPool() {
        ExecutorService executorService = Executors.newFixedThreadPool(3);
        for (int i = 0; i < 10; i++) {
            final int index = i;
            executorService.execute(() -> {
                // 获取线程名称,默认格式:pool-1-thread-1
                System.out.println(DateUtil.now() + " " + Thread.currentThread().getName() + " " + index);
                // 等待2秒
                sleep(2000);
            });
        }
    }
```



### 计划

设置总共3个线程，并且延时3s执行，类似js里面的setTimeout

```java
private static void createScheduledThreadPool() {
        ScheduledExecutorService executorService = Executors.newScheduledThreadPool(3);
        System.out.println(DateUtil.now() + " 提交任务");
        for (int i = 0; i < 10; i++) {
            final int index = i;
            executorService.schedule(() -> {
                // 获取线程名称,默认格式:pool-1-thread-1
                System.out.println(DateUtil.now() + " " + Thread.currentThread().getName() + " " + index);
                // 等待2秒
                sleep(2000);
            }, 3, TimeUnit.SECONDS);
        }
    }


```





## 线程顺序执行

join、锁、同步信号量

### **join**

```java
public class MyThread {
    public static void main(String[] args) {
        Thread t1 = new Thread() {
            @Override
            public void run() {
                System.out.println("t1.run");
            }
        };
        Thread t2 = new Thread() {
            @Override
            public void run() {
                try {
                    t1.join();
                    System.out.println("t2.run");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };
        Thread t3 = new Thread() {
            @Override
            public void run() {
                try {
                    t2.join();
                    System.out.println("t3.run");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };
        t1.start();
        t2.start();
        t3.start();
    }
}
```



```java
/**
 * 异步执行 与顺序形成对比
 */
public class ThreadNot {
    public static void main(String[] args) {
        Thread t1 = new Thread() {
            @Override
            public void run() {
                System.out.println("t1.run");
            }
        };
        Thread t2 = new Thread() {
            @Override
            public void run() {
                System.out.println("t2.run");
            }
        };
        Thread t3 = new Thread() {
            @Override
            public void run() {
                System.out.println("t3.run");
            }
        };
        t1.start();
        t2.start();
        t3.start();
    }
}
```

### 同步代码块

```java
public class UseWaitSynchronize {

    private static Object myLock1 = new Object();
    private static Object myLock2 = new Object();

    public static void main(String[] args) {

        final Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (myLock1) {
                    System.out.println("产品经理规划新需求...");
                }
            }
        });

        final Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (myLock1) {
                    synchronized (myLock2) {
                        System.out.println("开发人员开发新需求功能");
                        myLock2.notify();
                    }
                }
            }
        });

        Thread thread3 = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (myLock2) {
                    System.out.println("测试人员测试新功能");
                }
            }
        });

        System.out.println("早上：");
        System.out.println("产品经理来上班了...");
        System.out.println("开发人员来上班了...");
        System.out.println("测试人员来上班了...");
        thread1.start();
        thread2.start();
        thread3.start();
    }
}
```

### 单线程池

```java
/**
 * @author wwj
 * 通过SingleThreadExecutor让线程按顺序执行
 */
public class ThreadPoolDemo {

    public static void main(String[] args) throws Exception {
        ExecutorService executorService = Executors.newSingleThreadExecutor();

        final Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("产品经理规划新需求");
            }
        });

        final Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("开发人员开发新需求功能");
            }
        });

        Thread thread3 = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("测试人员测试新功能");
            }
        });

        System.out.println("早上：");
        System.out.println("首先，产品经理规划新需求...");
        executorService.submit(thread1);
        System.out.println("然后，开发人员开发新需求功能...");
        executorService.submit(thread2);
        System.out.println("最后，测试人员测试新功能...");
        executorService.submit(thread3);
        executorService.shutdown();
    }
}
```





