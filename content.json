{"meta":{"title":"Yuan","subtitle":"","description":"Challenge is the only redemption","author":"Yuan","url":"https://illuca.github.io","root":"/"},"pages":[{"title":"categories","date":"2021-09-02T16:38:28.000Z","updated":"2023-05-12T13:59:08.921Z","comments":true,"path":"categories/index.html","permalink":"https://illuca.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2021-09-02T16:22:00.000Z","updated":"2023-05-12T13:59:08.921Z","comments":true,"path":"about/index.html","permalink":"https://illuca.github.io/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2021-09-02T16:38:35.000Z","updated":"2023-11-02T09:58:16.456Z","comments":true,"path":"tags/index.html","permalink":"https://illuca.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"3101. 交替子数组计数","slug":"3101-交替子数组计数","date":"2024-05-04T15:01:35.000Z","updated":"2024-05-04T13:04:05.245Z","comments":true,"path":"2024/05/05/3101-交替子数组计数/","link":"","permalink":"https://illuca.github.io/2024/05/05/3101-%E4%BA%A4%E6%9B%BF%E5%AD%90%E6%95%B0%E7%BB%84%E8%AE%A1%E6%95%B0/","excerpt":"","text":"https://leetcode.cn/problems/count-alternating-subarrays/description/ 输入： nums = [0,1,1,1] 输出： 5 5=1+2+1+1 输入： nums = [1,0,1,0] 输出： 10 10=1+2+3+4 可以发现规律，如果不重复，就是每次累加，否则个数就只是+1。 所以一次遍历就足够。 12345678910111213141516171819202122/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var countAlternatingSubarrays = function(nums) &#123; if(!nums || nums.length==0)&#123; return 0 &#125; let i=1 // pointer let k=1 // counter let R=1 for(i=1;i&lt;nums.length;i++)&#123; if(nums[i]!==nums[i-1])&#123; k+=1 R+=k &#125;else&#123; k=1 R+=1 &#125; &#125; return R&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"https://illuca.github.io/tags/array/"}]},{"title":"3100. 换水问题 II","slug":"3100-换水问题-II","date":"2024-05-04T14:49:06.000Z","updated":"2024-05-04T12:49:53.667Z","comments":true,"path":"2024/05/05/3100-换水问题-II/","link":"","permalink":"https://illuca.github.io/2024/05/05/3100-%E6%8D%A2%E6%B0%B4%E9%97%AE%E9%A2%98-II/","excerpt":"","text":"https://leetcode.cn/problems/water-bottles-ii/ 1234567891011121314151617/** * @param &#123;number&#125; numBottles * @param &#123;number&#125; numExchange * @return &#123;number&#125; */var maxBottlesDrunk = function(B, E) &#123; let R=0 let empty=0 while(true)&#123; [B,empty,R]=[0,empty+B,R+B] if(B==0&amp;&amp;empty&lt;E)&#123; break &#125; [B,empty,E]=[1,empty-E,E+1] &#125; return R&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"simulation","slug":"simulation","permalink":"https://illuca.github.io/tags/simulation/"}]},{"title":"1110. Delete Nodes And Return Forest","slug":"1110-Delete-Nodes-And-Return-Forest","date":"2024-05-03T16:25:27.000Z","updated":"2024-05-03T14:32:04.732Z","comments":true,"path":"2024/05/04/1110-Delete-Nodes-And-Return-Forest/","link":"","permalink":"https://illuca.github.io/2024/05/04/1110-Delete-Nodes-And-Return-Forest/","excerpt":"","text":"后序遍历 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @param &#123;number[]&#125; to_delete * @return &#123;TreeNode[]&#125; */var delNodes = function(root, to_delete) &#123; let R=[] let S=new Set(to_delete) if(!to_delete.includes(root.val))&#123; R.push(root) &#125; dfs(root) return R function dfs(curr)&#123; if(!curr)&#123; return null &#125; curr.left=dfs(curr.left) curr.right=dfs(curr.right) if(S.has(curr.val))&#123; console.log(curr.val) if(curr.left) &#123; R.push(curr.left) &#125; if(curr.right) &#123; R.push(curr.right) &#125; return null &#125;else&#123; return curr &#125; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"tree","slug":"tree","permalink":"https://illuca.github.io/tags/tree/"},{"name":"dfs","slug":"dfs","permalink":"https://illuca.github.io/tags/dfs/"}]},{"title":"1109. Corporate Flight Bookings","slug":"1109-Corporate-Flight-Bookings","date":"2024-05-03T15:51:08.000Z","updated":"2024-05-03T13:52:39.424Z","comments":true,"path":"2024/05/04/1109-Corporate-Flight-Bookings/","link":"","permalink":"https://illuca.github.io/2024/05/04/1109-Corporate-Flight-Bookings/","excerpt":"","text":"https://leetcode.cn/problems/corporate-flight-bookings/ 12345678910111213141516171819202122/** * @param &#123;number[][]&#125; bookings * @param &#123;number&#125; n * @return &#123;number[]&#125; */var corpFlightBookings = function(bookings, n) &#123; let R=new Array(n+1).fill(0) for(let booking of bookings)&#123; let [first,last,seats]=booking R[first]+=seats if(last+1&lt;R.length)&#123; //之后累加时，从first到last都会累计+seats的buff，而为了去buff， //就需要对last+1上debuff R[last+1]-=seats &#125; &#125; for(let i=2;i&lt;n+1;i++)&#123; R[i]+=R[i-1] &#125; R.shift() return R&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"prefix sum","slug":"prefix-sum","permalink":"https://illuca.github.io/tags/prefix-sum/"}]},{"title":"151. Reverse Words in a String","slug":"151-Reverse-Words-in-a-String","date":"2024-04-30T15:02:59.000Z","updated":"2024-04-30T13:20:12.918Z","comments":true,"path":"2024/05/01/151-Reverse-Words-in-a-String/","link":"","permalink":"https://illuca.github.io/2024/05/01/151-Reverse-Words-in-a-String/","excerpt":"","text":"1234567891011121314151617181920function reverseWords(s: string): string &#123; let tmp=[] let A=[] for(let i=0;i&lt;s.length;i++)&#123; if(s[i]===&#x27; &#x27;)&#123; if(tmp.length&gt;0) &#123; A.push(tmp.join(&#x27;&#x27;)) tmp=[] &#125; continue &#125; if(s[i]!==&#x27; &#x27;)&#123; tmp.push(s[i]) &#125; &#125; if(tmp.length&gt;0)&#123; A.push(tmp.join(&#x27;&#x27;)) &#125; return A.reverse().join(&#x27; &#x27;)&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"string","slug":"string","permalink":"https://illuca.github.io/tags/string/"}]},{"title":"6. Zigzag Conversion","slug":"6-Zigzag-Conversion","date":"2024-04-30T14:19:15.000Z","updated":"2024-04-30T12:31:01.751Z","comments":true,"path":"2024/05/01/6-Zigzag-Conversion/","link":"","permalink":"https://illuca.github.io/2024/05/01/6-Zigzag-Conversion/","excerpt":"","text":"https://leetcode.com/problems/zigzag-conversion/description/ 12345678910111213141516171819202122232425262728class Solution: def convert(self, s: str, nrows: int) -&gt; str: if nrows==1: return s D=defaultdict(list) # traverse row and once reach the ceil or bottom, then # change direction and increase/stop increase column k=0 i=0 j=0 direction=True increase=False while k&lt;len(s): D[i].append(s[k]) k+=1 if direction: i+=1 else: i-=1 if increase: j+=1 if k%(nrows-1)==0: direction=not direction increase=not increase R=&quot;&quot; for row in range(nrows): R+=&quot;&quot;.join(D[row]) return R Actually, we don’t need increase variable. But it is simulation, so i keep it there.","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"string","slug":"string","permalink":"https://illuca.github.io/tags/string/"}]},{"title":"56. Merge Intervals","slug":"56-Merge-Intervals","date":"2024-04-29T15:15:04.000Z","updated":"2024-04-29T13:23:41.663Z","comments":true,"path":"2024/04/30/56-Merge-Intervals/","link":"","permalink":"https://illuca.github.io/2024/04/30/56-Merge-Intervals/","excerpt":"","text":"123456789101112131415161718192021function merge(A: number[][]): number[][] &#123; if(!A)&#123; return A &#125; let [i,k]=[1,0] A.sort((a,b)=&gt;&#123; return a[0]-b[0] &#125;) let R=[A[0]] while(true)&#123; while(i&lt;A.length &amp;&amp; R[k][1]&lt;A[i][0]) &#123; R.push(A[i]) k++ i++ &#125; if(i&gt;=A.length) break R[k][1]=Math.max(R[k][1],A[i][1]) i+=1 &#125; return R&#125;; It can be simplified: 123456789101112131415161718192021222324function merge(A: number[][]): number[][] &#123; if(!A)&#123; return A &#125; let [i,k]=[1,0] A.sort((a,b)=&gt;&#123; return a[0]-b[0] &#125;) let R=[] for(let i=0;i&lt;A.length;i++)&#123; if(R.length==0)&#123; R.push(A[i]) continue &#125; if(R[R.length-1][1]&lt;A[i][0])&#123; R.push(A[i]) continue &#125; if(R[R.length-1][1]&gt;=A[i][0])&#123; R[R.length-1][1]=Math.max(R[R.length-1][1], A[i][1]) &#125; &#125; return R&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"https://illuca.github.io/tags/array/"}]},{"title":"57. Insert Interval","slug":"57-Insert-Interval","date":"2024-04-29T14:23:06.000Z","updated":"2024-04-29T12:23:43.625Z","comments":true,"path":"2024/04/30/57-Insert-Interval/","link":"","permalink":"https://illuca.github.io/2024/04/30/57-Insert-Interval/","excerpt":"","text":"1234567891011121314151617181920212223function insert(A: number[][], T: number[]): number[][] &#123; let i=0 // currrent ends before T start let res=[] while(i&lt;A.length &amp;&amp; A[i][1]&lt;T[0])&#123; res.push(A[i]) i+=1 &#125; let u=[T[0],T[1]] // handle overlap part while(i&lt;A.length &amp;&amp; A[i][0]&lt;=T[1])&#123; u[0]=Math.min(u[0],A[i][0]) u[1]=Math.max(u[1],A[i][1]) i+=1 &#125; res.push(u) // handle the rest while(i&lt;A.length)&#123; res.push(A[i]) i+=1 &#125; return res&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"https://illuca.github.io/tags/array/"}]},{"title":"80. Remove Duplicates from Sorted Array II","slug":"80-Remove-Duplicates-from-Sorted-Array-II","date":"2024-04-28T09:28:53.000Z","updated":"2024-04-28T07:29:54.410Z","comments":true,"path":"2024/04/28/80-Remove-Duplicates-from-Sorted-Array-II/","link":"","permalink":"https://illuca.github.io/2024/04/28/80-Remove-Duplicates-from-Sorted-Array-II/","excerpt":"","text":"12345678910111213141516171819202122var removeDuplicates = function(nums) &#123; let k=0,counter=1 for(let i=0;i&lt;nums.length;i++)&#123; if(i==0)&#123; nums[k]=nums[i] k++ continue &#125; if(nums[i]==nums[i-1])&#123; counter++ &#125;else&#123; counter=1 &#125; //only keep those counter less than 2 if(counter&lt;=2)&#123; nums[k]=nums[i] k++ &#125; &#125; return k&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"https://illuca.github.io/tags/array/"},{"name":"two pointers","slug":"two-pointers","permalink":"https://illuca.github.io/tags/two-pointers/"}]},{"title":"97. Interleaving String","slug":"97-Interleaving-String","date":"2024-02-11T07:49:53.000Z","updated":"2024-02-11T09:27:19.380Z","comments":true,"path":"2024/02/11/97-Interleaving-String/","link":"","permalink":"https://illuca.github.io/2024/02/11/97-Interleaving-String/","excerpt":"","text":"https://leetcode.com/problems/interleaving-string/?envType=study-plan-v2&amp;envId=top-interview-150 Solution1: 12345678910111213141516171819class Solution: def isInterleave(self, s1: str, s2: str, s3: str) -&gt; bool: @cache def f(i,j,k): if i&lt;len(s1) and j&lt;len(s2): if s1[i]==s3[k] and s2[j]==s3[k]: return f(i+1,j,k+1) or f(i,j+1,k+1) if s1[i]==s3[k]: return f(i+1,j,k+1) if s2[j]==s3[k]: return f(i,j+1,k+1) if i&lt;len(s1): return s1[i]==s3[k] and f(i+1,j,k+1) if j&lt;len(s2): return s2[j]==s3[k] and f(i,j+1,k+1) return True if len(s1)+len(s2)!=len(s3): return False return f(0,0,0) Solution2: 1234567891011121314class Solution: def isInterleave(self, s1: str, s2: str, s3: str) -&gt; bool: if len(s1) + len(s2) != len(s3): return False dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)] dp[0][0] = True for i in range(len(s1)+1): for j in range(len(s2)+1): if i&gt;=1: dp[i][j]|=dp[i-1][j] and s1[i-1]==s3[i+j-1] if j&gt;=1: dp[i][j]|=dp[i][j-1] and s2[j-1]==s3[i+j-1] return dp[len(s1)][len(s2)]","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"DP","slug":"DP","permalink":"https://illuca.github.io/tags/DP/"},{"name":"memorization","slug":"memorization","permalink":"https://illuca.github.io/tags/memorization/"}]},{"title":"64. Minimum Path Sum","slug":"64-Minimum-Path-Sum","date":"2024-01-15T17:50:55.000Z","updated":"2024-01-15T17:55:28.419Z","comments":true,"path":"2024/01/16/64-Minimum-Path-Sum/","link":"","permalink":"https://illuca.github.io/2024/01/16/64-Minimum-Path-Sum/","excerpt":"","text":"https://leetcode.com/problems/minimum-path-sum/description/ 1234567891011121314class Solution: def minPathSum(self, G: List[List[int]]) -&gt; int: Z=[[0]*len(G[0]) for _ in range(len(G))] for i in range(len(G)): for j in range(len(G[0])): if i==0 and j==0: Z[i][j]=G[i][j] elif i==0: Z[i][j]=Z[i][j-1]+G[i][j] elif j==0: Z[i][j]=Z[i-1][j]+G[i][j] else: Z[i][j]=min(Z[i-1][j],Z[i][j-1])+G[i][j] return Z[-1][-1]","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"dp","slug":"dp","permalink":"https://illuca.github.io/tags/dp/"}]},{"title":"62. Unique Paths","slug":"62-Unique-Paths","date":"2024-01-15T16:08:47.000Z","updated":"2024-01-15T16:13:55.840Z","comments":true,"path":"2024/01/16/62-Unique-Paths/","link":"","permalink":"https://illuca.github.io/2024/01/16/62-Unique-Paths/","excerpt":"","text":"https://leetcode.com/problems/unique-paths/description/ Solution1: top down dp 1234567class Solution: @cache def uniquePaths(self, m: int, n: int) -&gt; int: if m==1 or n==1: return 1 elif m&gt;1 and n&gt;1: return self.uniquePaths(m-1,n)+self.uniquePaths(m,n-1) Solution2: bottom up dp 123456789101112131415class Solution: def uniquePaths(self, m: int, n: int) -&gt; int: &quot;&quot;&quot; assume we have solved P(i-1,j) and P(i,j-1) then P(i,j)=P(i-1,j)+P(i,j-1) &quot;&quot;&quot; P=[[0]*n for _ in range(m)] for i in range(n): P[0][i]=1 for j in range(m): P[j][0]=1 for i in range(1,m): for j in range(1,n): P[i][j]=P[i-1][j]+P[i][j-1] return P[m-1][n-1]","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"dp","slug":"dp","permalink":"https://illuca.github.io/tags/dp/"}]},{"title":"45. Jump Game II","slug":"45-Jump-Game-II","date":"2024-01-15T15:29:58.000Z","updated":"2024-01-15T15:32:52.689Z","comments":true,"path":"2024/01/16/45-Jump-Game-II/","link":"","permalink":"https://illuca.github.io/2024/01/16/45-Jump-Game-II/","excerpt":"","text":"https://leetcode.com/problems/jump-game-ii/ We always make our furthest step and when i is bigger than far, we need to make one more step. 1234567891011121314class Solution: def jump(self, A: List[int]) -&gt; int: if not A: return 0 if A: Z=0 end=0 far=0 for i in range(len(A)-1): far=max(far,i+A[i]) if i==end: Z+=1 end=far return Z","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"greedy","slug":"greedy","permalink":"https://illuca.github.io/tags/greedy/"}]},{"title":"131. Palindrome Partitioning","slug":"131-Palindrome-Partitioning","date":"2024-01-12T16:38:20.000Z","updated":"2024-01-12T16:39:00.385Z","comments":true,"path":"2024/01/13/131-Palindrome-Partitioning/","link":"","permalink":"https://illuca.github.io/2024/01/13/131-Palindrome-Partitioning/","excerpt":"","text":"https://leetcode.com/problems/palindrome-partitioning/ 1234567891011121314151617181920212223242526class Solution: def partition(self, A: str) -&gt; List[List[str]]: def g(l,r): while l&lt;=r: if A[l]!=A[r]: return False elif A[l]==A[r]: l+=1 r-=1 return True def f(start,C): if start&gt;=len(A): Z.append(C[:]) return if start&lt;len(A): for end in range(start,len(A)): if g(start,end): C.append(A[start:end+1]) f(end+1,C) C.pop() if not A: return [] Z=[] f(0,[]) return Z","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"backtrack","slug":"backtrack","permalink":"https://illuca.github.io/tags/backtrack/"}]},{"title":"79. Word Search","slug":"79-Word-Search","date":"2024-01-12T09:28:45.000Z","updated":"2024-01-12T11:54:07.695Z","comments":true,"path":"2024/01/12/79-Word-Search/","link":"","permalink":"https://illuca.github.io/2024/01/12/79-Word-Search/","excerpt":"","text":"https://leetcode.com/problems/word-search/ 123456789101112131415161718class Solution: def exist(self, A: List[List[str]], W: str) -&gt; bool: def f(x,y,idx): nonlocal Z if idx&gt;=len(W): Z=True elif idx&lt;len(W) and 0&lt;=x&lt;len(A) and 0&lt;=y&lt;len(A[0]) and A[x][y]==W[idx] and (x,y) not in S: S.add((x,y)) for a,b in [(x+1,y),(x-1,y),(x,y+1),(x,y-1)]: if not Z: f(a,b,idx+1) S.discard((x,y)) Z=False for i in range(len(A)): for j in range(len(A[0])): S=set() f(i,j,0) return Z We can set A[x][y] as # to mark it as visited to prevent the same cell from being visited more than one time. 1234567891011121314151617class Solution: def exist(self, A: List[List[str]], W: str) -&gt; bool: def f(x,y,idx): nonlocal Z if idx&gt;=len(W): Z=True elif idx&lt;len(W) and 0&lt;=x&lt;len(A) and 0&lt;=y&lt;len(A[0]) and A[x][y]==W[idx]: A[x][y]=&#x27;#&#x27; for a,b in [(x+1,y),(x-1,y),(x,y+1),(x,y-1)]: if not Z: f(a,b,idx+1) A[x][y]=W[idx] Z=False for i in range(len(A)): for j in range(len(A[0])): f(i,j,0) return Z","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"backtrack","slug":"backtrack","permalink":"https://illuca.github.io/tags/backtrack/"}]},{"title":"148. Sort List","slug":"148-Sort-List","date":"2024-01-08T16:10:04.000Z","updated":"2024-04-28T06:01:28.787Z","comments":true,"path":"2024/01/09/148-Sort-List/","link":"","permalink":"https://illuca.github.io/2024/01/09/148-Sort-List/","excerpt":"","text":"https://leetcode.com/problems/sort-list/ Solution1: hash table1234567891011121314class Solution: def sortList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: p=head A=[] if not head: return None while p: A.append(p) p=p.next A.sort(key=lambda x:x.val) for i in range(len(A)-1): A[i].next=A[i+1] A[-1].next=None return A[0] 12345678910111213141516171819var sortList = function(head) &#123; if(!head)&#123; return head &#125; let A=[] let p=head while(p)&#123; A.push(p) p=p.next &#125; A.sort((a,b)=&gt;&#123; return a.val-b.val &#125;) for(let i=0;i&lt;A.length-1;i++)&#123; A[i].next=A[i+1] &#125; A[A.length-1].next=null return A[0]&#125;; TopDown merge sortDivide: The original list is divided into two halves. And we repeat the process until the base case is reached, which is a sublist of 0 or 1 element. Conquer: The list that has 0 or 1 element is originally sorted. Combine: We merge two sorted sublist into a single sorted list. 12345678910111213141516171819202122232425262728293031323334353637var sortList = function(head) &#123; if(!head || !head.next) &#123; return head &#125; let mid=getMidAndSplit(head) let left=sortList(head) let right=sortList(mid) return merge(left,right) function getMidAndSplit(head)&#123; let slow=head let fast=head let slowPrev=head while(fast &amp;&amp; fast.next)&#123; [slow,slowPrev]=[slow.next,slow] fast=fast.next.next &#125; slowPrev.next=null return slow &#125; function merge(l,r)&#123; let dummy=new ListNode() let p=dummy while(l&amp;&amp;r)&#123; if(l.val&lt;r.val)&#123; p.next=l l=l.next &#125;else&#123; p.next=r r=r.next &#125; p=p.next &#125; p.next=l?l:r return dummy.next &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"linked list","slug":"linked-list","permalink":"https://illuca.github.io/tags/linked-list/"},{"name":"hash","slug":"hash","permalink":"https://illuca.github.io/tags/hash/"}]},{"title":"138. Copy List with Random Pointer","slug":"138-Copy-List-with-Random-Pointer","date":"2024-01-08T16:01:39.000Z","updated":"2024-01-08T13:02:06.760Z","comments":true,"path":"2024/01/09/138-Copy-List-with-Random-Pointer/","link":"","permalink":"https://illuca.github.io/2024/01/09/138-Copy-List-with-Random-Pointer/","excerpt":"","text":"Solution1: hash table 123456789101112131415161718192021222324252627class Solution: def copyRandomList(self, head: &#x27;Optional[Node]&#x27;) -&gt; &#x27;Optional[Node]&#x27;: if not head: return None D=&#123;&#125; p=head k=0 while p: D[p]=k p=p.next k+=1 p=head A=[] while p: A.append(ListNode(p.val)) p=p.next p=head for i in range(len(A)): if i&lt;len(A)-1: A[i].next=A[i+1] if p.random is None: A[i].random=None elif p.random: A[i].random=A[D[p.random]] p=p.next return A[0]","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"linked list","slug":"linked-list","permalink":"https://illuca.github.io/tags/linked-list/"}]},{"title":"24. Swap Nodes in Pairs","slug":"24-Swap-Nodes-in-Pairs","date":"2024-01-08T15:08:01.000Z","updated":"2024-01-08T12:28:44.445Z","comments":true,"path":"2024/01/09/24-Swap-Nodes-in-Pairs/","link":"","permalink":"https://illuca.github.io/2024/01/09/24-Swap-Nodes-in-Pairs/","excerpt":"","text":"https://leetcode.com/problems/swap-nodes-in-pairs/description/ 123456789101112131415161718class Solution: def swapPairs(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: def swap(prev): p=prev.next if prev.next is None or prev.next.next is None: return None elif prev.next and prev.next.next: p=prev.next q=prev.next.next prev.next=p.next p.next=q.next q.next=p return p dummy=ListNode(-1,head) prev=dummy while prev: prev=swap(prev) return dummy.next The simplest solution: 12345678910111213141516171819class Solution: def swapPairs(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: if not head: return None A=[] p=head while p: A.append(p) p=p.next for i in range(1,len(A),2): A[i],A[i-1]=A[i-1],A[i] dummy=ListNode(-1) p=dummy for i in range(len(A)): p.next=A[i] p=p.next A[-1].next=None return dummy.next","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"linked list","slug":"linked-list","permalink":"https://illuca.github.io/tags/linked-list/"}]},{"title":"19. Remove Nth Node From End of List","slug":"19-Remove-Nth-Node-From-End-of-List","date":"2024-01-08T14:24:15.000Z","updated":"2024-01-08T11:55:45.049Z","comments":true,"path":"2024/01/09/19-Remove-Nth-Node-From-End-of-List/","link":"","permalink":"https://illuca.github.io/2024/01/09/19-Remove-Nth-Node-From-End-of-List/","excerpt":"","text":"https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/ Solution1: two iteration 12345678910111213141516171819class Solution: def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]: dummy=ListNode() dummy.next=head p=dummy total=0 while p: p=p.next total+=1 m=total-n p=dummy k=0 while k!=m: prev=p p=p.next k+=1 prev.next=p.next return dummy.next Solution2: one iteration 12345678910111213141516171819class Solution: def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]: &quot;&quot;&quot; q p -1 1 2 3 4 5 $ q p &quot;&quot;&quot; dummy=ListNode(-1,head) p=dummy k=0 while k!=n: p=p.next k+=1 q=dummy while p.next: p=p.next q=q.next q.next=q.next.next return dummy.next 123456789101112131415class Solution: def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]: def f(C): nonlocal k if C is None: return None elif C is not None: C.next=f(C.next) k+=1 if k==n: return C.next elif k!=n: return C k=0 return f(head)","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"linked list","slug":"linked-list","permalink":"https://illuca.github.io/tags/linked-list/"}]},{"title":"142. Linked List Cycle II","slug":"142-Linked-List-Cycle-II","date":"2024-01-08T10:46:05.000Z","updated":"2024-01-08T08:53:28.483Z","comments":true,"path":"2024/01/08/142-Linked-List-Cycle-II/","link":"","permalink":"https://illuca.github.io/2024/01/08/142-Linked-List-Cycle-II/","excerpt":"","text":"https://leetcode.com/problems/linked-list-cycle-ii/ Solution1: hash table 12345678910111213class Solution: def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: D=&#123;&#125; p=head k=0 while p: if p in D: return p else: D[p]=k k+=1 p=p.next return None Solution2: Floyd’s cycle-finding algorithm 123456789101112131415161718192021class Solution: def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: slow=head fast=head while slow and fast: slow=slow.next if fast.next is None: fast=None elif fast.next is not None: fast=fast.next.next if slow==fast: break # pattern match exit of loop if fast is None: return None elif fast is not None: fast=head while slow!=fast: slow=slow.next fast=fast.next return slow 123456789101112131415161718class Solution: def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: slow=head fast=head while fast and fast.next: slow=slow.next fast=fast.next.next if slow==fast: break # because our while has two exit, so we need to discuss if fast is None or fast.next is None: return None elif fast and fast.next: fast=head while fast!=slow: fast=fast.next slow=slow.next return fast","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"linked list","slug":"linked-list","permalink":"https://illuca.github.io/tags/linked-list/"}]},{"title":"208. Implement Trie (Prefix Tree)","slug":"208-Implement-Trie-Prefix-Tree","date":"2024-01-08T10:24:11.000Z","updated":"2024-01-08T07:24:45.271Z","comments":true,"path":"2024/01/08/208-Implement-Trie-Prefix-Tree/","link":"","permalink":"https://illuca.github.io/2024/01/08/208-Implement-Trie-Prefix-Tree/","excerpt":"","text":"https://leetcode.com/problems/implement-trie-prefix-tree/description/ 123456789101112131415161718192021222324252627282930313233343536373839class TreeNode: def __init__(self,ch): self.ch=ch self.children=&#123;&#125; self.isEnd=Falseclass Trie: def __init__(self): self.root=TreeNode(&quot;&quot;) def insert(self, W: str) -&gt; None: C=self.root for w in W: if w in C.children: C=C.children[w] else: C.children[w]=TreeNode(w) C=C.children[w] C.isEnd=True def search(self, W: str) -&gt; bool: C=self.root for w in W: if w in C.children: C=C.children[w] else: return False return C.isEnd def startsWith(self, W: str) -&gt; bool: C=self.root for w in W: if w in C.children: C=C.children[w] else: return False return True","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"string","slug":"string","permalink":"https://illuca.github.io/tags/string/"},{"name":"prefix","slug":"prefix","permalink":"https://illuca.github.io/tags/prefix/"}]},{"title":"763. Partition Labels","slug":"763-Partition-Labels","date":"2024-01-08T08:15:35.000Z","updated":"2024-01-08T05:18:35.760Z","comments":true,"path":"2024/01/08/763-Partition-Labels/","link":"","permalink":"https://illuca.github.io/2024/01/08/763-Partition-Labels/","excerpt":"","text":"https://leetcode.com/problems/partition-labels/ You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part. Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s. Return a list of integers representing the size of these parts. Solution1: Greedy Once we see “as many parts as possible”, it tends to be a problem of greedy or dp. 1234567891011121314class Solution: def partitionLabels(self, A: str) -&gt; List[int]: D=defaultdict(int) for i in range(len(A)): D[A[i]]=i M=0 Z=[] prev=0 for i in range(len(A)): M=max(M,D[A[i]]) if i==M: Z.append(i-prev+1) prev=i+1 return Z","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"greedy","slug":"greedy","permalink":"https://illuca.github.io/tags/greedy/"}]},{"title":"739. Daily Temperatures","slug":"739-Daily-Temperatures","date":"2024-01-05T14:58:00.000Z","updated":"2024-01-05T11:58:16.333Z","comments":true,"path":"2024/01/06/739-Daily-Temperatures/","link":"","permalink":"https://illuca.github.io/2024/01/06/739-Daily-Temperatures/","excerpt":"","text":"https://leetcode.com/problems/daily-temperatures/ 123456789101112131415class Solution: def dailyTemperatures(self, A: List[int]) -&gt; List[int]: if not A: return [] if A: S=[(0,A[0])] Z=[0]*len(A) i=1 while i&lt;len(A): while S and A[i]&gt;S[-1][1]: Z[S[-1][0]]=i-S[-1][0] S.pop() S.append((i,A[i])) i+=1 return Z","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"stack","slug":"stack","permalink":"https://illuca.github.io/tags/stack/"}]},{"title":"394. Decode String","slug":"394-Decode-String","date":"2024-01-05T10:16:17.000Z","updated":"2024-01-05T11:57:50.391Z","comments":true,"path":"2024/01/05/394-Decode-String/","link":"","permalink":"https://illuca.github.io/2024/01/05/394-Decode-String/","excerpt":"","text":"https://leetcode.com/problems/decode-string/ 123456789101112131415161718192021222324252627282930313233from collections import dequeclass Solution: def decodeString(self, A: str) -&gt; str: def f(): p=i base=1 res=0 while Z and Z[-1].isdigit(): res+=base*int(Z.pop()) base*=10 return res Z=[] i=0 while i&lt;len(A): a=A[i] if a==&#x27;]&#x27;: tmp=deque() while Z: x=Z.pop() if x==&#x27;[&#x27;: k=f() tmp=k*tmp break tmp.appendleft(x) Z.extend(tmp) i+=1 continue if a!=&#x27;]&#x27;: Z.append(a) i+=1 return &quot;&quot;.join(Z)","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"stack","slug":"stack","permalink":"https://illuca.github.io/tags/stack/"}]},{"title":"155. Min Stack","slug":"155-Min-Stack","date":"2024-01-05T08:52:22.000Z","updated":"2024-01-05T06:03:33.038Z","comments":true,"path":"2024/01/05/155-Min-Stack/","link":"","permalink":"https://illuca.github.io/2024/01/05/155-Min-Stack/","excerpt":"","text":"https://leetcode.com/problems/min-stack/ Solution1: two stacks 123456789101112131415161718192021222324class MinStack: def __init__(self): self.A=[] self.C=[] def push(self, x: int) -&gt; None: self.A.append(x) if not self.C or x&lt;self.C[-1][0]: self.C.append([x,1]) elif x==self.C[-1][0]: self.C[-1][1]+=1 def pop(self) -&gt; None: if self.A.pop()==self.C[-1][0]: self.C[-1][1]-=1 if self.C[-1][1]==0: self.C.pop() def top(self) -&gt; int: return self.A[-1] def getMin(self) -&gt; int: return self.C[-1][0] Solution2: always store minimum value on top of the stack 123456789101112131415161718192021222324252627282930class MinStack: def __init__(self): self.A=[] def push(self, x: int) -&gt; None: if not self.A: self.A.append((x,x)) return if self.A: m=min(self.A[-1][1],x) self.A.append((x,m)) def pop(self) -&gt; None: if not self.A: return if A: self.A.pop() def top(self) -&gt; int: if not self.A: return -1 if A: return self.A[-1][0] def getMin(self) -&gt; int: if not self.A: return -1 if A: return self.A[-1][1]","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"stack","slug":"stack","permalink":"https://illuca.github.io/tags/stack/"}]},{"title":"55. Jump Game","slug":"55-Jump-Game","date":"2024-01-03T15:11:09.000Z","updated":"2024-01-09T04:43:43.455Z","comments":true,"path":"2024/01/04/55-Jump-Game/","link":"","permalink":"https://illuca.github.io/2024/01/04/55-Jump-Game/","excerpt":"","text":"https://leetcode.cn/problems/jump-game/?envType=study-plan-v2&amp;envId=top-100-liked Solution1: memorized recursion 1234567891011121314151617181920class Solution: def canJump(self, A: List[int]) -&gt; bool: def f(i): if memo[i]==1: return True if memo[i]==-1: return False if memo[i]==0: M=min(i+A[i],target) for x in range(i+1,M+1): if f(x): memo[i]=True return True memo[i]=-1 return False memo=[0]*len(A) target=len(A)-1 memo[-1]=1 return f(0) Solution2: Optimized memorized recursion 12345678910111213class Solution: def canJump(self, A: List[int]) -&gt; bool: memo=[0]*len(A) memo[-1]=1 target=len(A)-1 for i in range(len(A)-2,-1,-1): M=min(i+A[i],target) for j in range(i+1,M+1): # if any j can reach last index, then i can reach since i can jump up to M steps (1&lt;=j&lt;=M) if memo[j]==1: memo[i]=1 break return memo[0]==1 Solution3: Greedy If position i can reach the last index, then who can ever reach i will also can reach the last index. It is like that we want to find a person can beat X. If A can beats X, then the one who is stronger than A can also beats X. 1234567class Solution: def canJump(self, A: List[int]) -&gt; bool: last=len(A)-1 for i in range(len(A)-1,-1,-1): if i+A[i]&gt;=last: last=i return last==0","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"DP","slug":"DP","permalink":"https://illuca.github.io/tags/DP/"},{"name":"greedy","slug":"greedy","permalink":"https://illuca.github.io/tags/greedy/"}]},{"title":"347. Top K Frequent Elements","slug":"347-Top-K-Frequent-Elements","date":"2024-01-03T13:13:08.000Z","updated":"2024-01-03T10:22:43.594Z","comments":true,"path":"2024/01/04/347-Top-K-Frequent-Elements/","link":"","permalink":"https://illuca.github.io/2024/01/04/347-Top-K-Frequent-Elements/","excerpt":"","text":"https://leetcode.com/problems/top-k-frequent-elements/description/ Solution1: max heap 123456789101112131415class Solution: def topKFrequent(self, A: List[int], k: int) -&gt; List[int]: D=defaultdict(int) for a in A: D[a]+=1 H=[] t=0 for key,value in D.items(): t+=1 heapq.heappush(H,(-value,t,key)) Z=[] for i in range(k): _,_,x=heapq.heappop(H) Z.append(x) return Z Solution2: min heap 12345678910111213141516class Solution: def topKFrequent(self, A: List[int], k: int) -&gt; List[int]: D=defaultdict(int) for a in A: D[a]+=1 H=[] t=0 for num,freq in D.items(): if len(H)&gt;=k: if freq&gt;H[0][0]: heapq.heappop(H) else: continue t+=1 heapq.heappush(H,(freq,t,num)) return [x[2] for x in H]","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"heap","slug":"heap","permalink":"https://illuca.github.io/tags/heap/"}]},{"title":"416. Partition Equal Subset Sum","slug":"416-Partition-Equal-Subset-Sum","date":"2024-01-03T12:29:24.000Z","updated":"2024-05-02T11:51:30.960Z","comments":true,"path":"2024/01/03/416-Partition-Equal-Subset-Sum/","link":"","permalink":"https://illuca.github.io/2024/01/03/416-Partition-Equal-Subset-Sum/","excerpt":"","text":"https://leetcode.com/problems/partition-equal-subset-sum/description/ Since the function f has overlapped computation, thus @cache can store those parts to speed up. 1234567891011121314151617class Solution: def canPartition(self, A: List[int]) -&gt; bool: @cache def f(curr,l,r): if curr&lt;0 or r&lt;0: return False if curr==0: return True if curr&gt;0: return f(curr-A[r],l,r-1) or f(curr,l,r-1) C=0 for i in range(len(A)): C+=A[i] if C%2==1: return False target=C//2 return f(target,0,len(A)-1) Use memo: memo[i][j] checks if A[i] has been calculated. memo[i][j] stores the result of include A[i] and exclude A[i]. 12345678910111213141516171819function canPartition(A: number[]): boolean &#123; let total = A.reduce((acc, curr) =&gt; acc + curr, 0) if (total % 2 === 1) return false let target = total / 2 let memo = new Array(A.length).fill(0).map(_ =&gt; new Array(target + 1).fill(0)) return f(0, target) function f(l, curr) &#123; if (curr == 0) return true if (curr &lt; 0 || l &gt;= A.length) return false if (curr &gt; 0) &#123; if (memo[l][curr] !== 0) &#123; return memo[l][curr] &#125; else &#123; memo[l][curr] = f(l + 1, curr - A[l]) || f(l + 1, curr) return memo[l][curr] &#125; &#125; &#125;&#125;; Unfortunately, python gets time limit exceeded. 1234567891011121314151617181920class Solution: def canPartition(self, A: List[int]) -&gt; bool: def f(curr, l): if curr &lt; 0 or l &gt;= len(A): return False if curr == 0: return True if curr &gt; 0: if memo[l][target] != 0: return memo[l][target] else: memo[l][target] = f(curr - A[l], l + 1) or f(curr, l + 1) return memo[l][target] total = sum(A) if total % 2 == 1: return False target = total // 2 memo = [[0] * (target + 1) for _ in range(len(A))] return f(target, 0) we can also use backtracking+memo 123456789101112131415161718192021222324252627282930313233let log=console.log.bind(console)function canPartition(A: number[]): boolean &#123; // for every item x in A, there is two possible, include x or not. // it is like a tree // to speed up, we need to build a memo and memo[i][j] // means the result of reaching j given A[i] let total=A.reduce((acc,curr)=&gt;acc+curr,0) if(total%2==1) return false let target=total/2 let memo=new Array(A.length+5).fill(0).map(_=&gt;new Array(target+5).fill(0)) return f(0,0) function f(l, curr) &#123; if(curr==target) return true if(l&gt;=A.length||curr&gt;target) return false if(curr&lt;target)&#123; if(memo[l][curr]!==0) &#123; return memo[l][curr] &#125;else&#123; for(let i=l;i&lt;A.length;i++)&#123; if(f(i+1,curr+A[l]) || f(i+1,curr))&#123; // if decision at l+1 can reach a solution to partition, // then current decision can reach too memo[i][curr]=true return true &#125; &#125; memo[l][curr]=false return false &#125; &#125; &#125;&#125;; 12345678910111213141516171819202122232425let log=console.log.bind(console)function canPartition(A: number[]): boolean &#123; // for every item x in A, there is two possible, include x or not. // it is like a tree // to speed up, we need to build a memo and memo[i][j] // means the result of reaching j given A[i] let total=A.reduce((acc,curr)=&gt;acc+curr,0) if(total%2==1) return false let target=total/2 let memo=new Array(A.length+5).fill(0).map(_=&gt;new Array(target+5).fill(0)) return f(0,0) function f(l, curr) &#123; if(curr==target) return true if(l&gt;=A.length||curr&gt;target) return false if(curr&lt;target)&#123; if(memo[l][curr]!==0) &#123; return memo[l][curr] &#125;else&#123; memo[l][curr]=f(l+1,curr+A[l])||f(l+1,curr) return memo[l][curr] &#125; &#125; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"DP","slug":"DP","permalink":"https://illuca.github.io/tags/DP/"},{"name":"backtrack","slug":"backtrack","permalink":"https://illuca.github.io/tags/backtrack/"}]},{"title":"300. Longest Increasing Subsequence","slug":"300-Longest-Increasing-Subsequence","date":"2024-01-01T15:44:46.000Z","updated":"2024-01-09T04:43:39.944Z","comments":true,"path":"2024/01/02/300-Longest-Increasing-Subsequence/","link":"","permalink":"https://illuca.github.io/2024/01/02/300-Longest-Increasing-Subsequence/","excerpt":"","text":"https://leetcode.com/problems/longest-increasing-subsequence/ P[i] denotes the maximum length of increasing subsequence that ends with A[i]. 1234567891011class Solution: def lengthOfLIS(self, A: List[int]) -&gt; int: if not A: return 0 N=len(A) P=[1]*N for i in range(N): for j in range(i): if A[j]&lt;A[i]: P[i]=max(P[i],P[j]+1) return max(P)","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"DP","slug":"DP","permalink":"https://illuca.github.io/tags/DP/"}]},{"title":"152. Maximum Product Subarray","slug":"152-Maximum-Product-Subarray","date":"2024-01-01T15:18:29.000Z","updated":"2024-01-09T04:43:33.772Z","comments":true,"path":"2024/01/02/152-Maximum-Product-Subarray/","link":"","permalink":"https://illuca.github.io/2024/01/02/152-Maximum-Product-Subarray/","excerpt":"","text":"https://leetcode.com/problems/maximum-product-subarray/description/ 1234567891011class Solution: def maxProduct(self, A: List[int]) -&gt; int: if not A: return 0 m=M=A[0] Z=M for i in range(1,len(A)): m,M=min(A[i],m*A[i],M*A[i]),max(A[i],m*A[i],M*A[i]) Z=max(Z,M) print(m,M) return Z Solution2: Kadane’s algorithm: https://www.geeksforgeeks.org/largest-sum-contiguous-subarray/ Once we meet zero, we reset our accumulated product. If the number of negative is even, then one forward loop will produce the maximum. If the number of positive is odd, then both forward loop and backward loop will produce a maximum. The forward loop will ignore the last negative number while the backward loop will ignore the first negative number. We select the larger one. 123456789101112131415161718class Solution: def maxProduct(self, A: List[int]) -&gt; int: C=1 M=A[0] # forward loop for i in range(len(A)): C=C*A[i] M=max(M,C) if A[i]==0: C=1 C=1 # backward loop for i in range(len(A)-1,-1,-1): C=C*A[i] M=max(M,C) if A[i]==0: C=1 return M","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"DP","slug":"DP","permalink":"https://illuca.github.io/tags/DP/"}]},{"title":"139. Word Break","slug":"139-Word-Break","date":"2023-12-31T15:47:30.000Z","updated":"2024-01-09T04:47:04.322Z","comments":true,"path":"2024/01/01/139-Word-Break/","link":"","permalink":"https://illuca.github.io/2024/01/01/139-Word-Break/","excerpt":"","text":"https://leetcode.com/problems/word-break/description/ It is similar to money change. Note: P[i] denotes whether substring up to i can be constructed by the word list. It is obvious that empty string is always able to be contructed. Thus P[0]=True. 12345678910class Solution: def wordBreak(self, s: str, W: List[str]) -&gt; bool: N=len(s) P=[False]*(N+1) P[0]=True for i in range(1,N+1): for w in W: if i-len(w)&gt;=0 and s[i-len(w):i]==w: P[i]=P[i] or P[i-len(w)] return P[-1]","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"DP","slug":"DP","permalink":"https://illuca.github.io/tags/DP/"},{"name":"sub","slug":"sub","permalink":"https://illuca.github.io/tags/sub/"},{"name":"string","slug":"string","permalink":"https://illuca.github.io/tags/string/"}]},{"title":"322. Coin Change","slug":"322-Coin-Change","date":"2023-12-30T12:32:45.000Z","updated":"2024-01-09T04:43:31.195Z","comments":true,"path":"2023/12/30/322-Coin-Change/","link":"","permalink":"https://illuca.github.io/2023/12/30/322-Coin-Change/","excerpt":"","text":"https://leetcode.com/problems/coin-change/description/ 123456789101112131415class Solution: def coinChange(self, A: List[int], T: int) -&gt; int: dp=[T+1]*(T+1) dp[0]=0 A.sort() for i in range(1,T+1): for a in A: if i-a&gt;=0: dp[i]=min(dp[i],dp[i-a]+1) else: break if dp[-1]==T+1: return -1 else: return dp[-1]","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"DP","slug":"DP","permalink":"https://illuca.github.io/tags/DP/"}]},{"title":"279. Perfect Squares","slug":"279-Perfect-Squares","date":"2023-12-30T12:08:03.000Z","updated":"2024-01-09T04:43:46.586Z","comments":true,"path":"2023/12/30/279-Perfect-Squares/","link":"","permalink":"https://illuca.github.io/2023/12/30/279-Perfect-Squares/","excerpt":"","text":"https://leetcode.com/problems/perfect-squares/ 1234567891011121314class Solution: def numSquares(self, n: int) -&gt; int: # find the biggest sqaure num that is smaller than n x=floor(sqrt(n)) Z=0 A=[i**2 for i in range(x+1)] dp=[n+1]*(n+1) dp[0]=0 for i in range(1,n+1): for a in A: if a&gt;i: break dp[i]=min(dp[i],dp[i-a]+1) return dp[-1]","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"DP","slug":"DP","permalink":"https://illuca.github.io/tags/DP/"}]},{"title":"118. Pascal's Triangle","slug":"118-Pascal-s-Triangle","date":"2023-12-28T08:45:19.000Z","updated":"2024-01-09T04:43:51.107Z","comments":true,"path":"2023/12/28/118-Pascal-s-Triangle/","link":"","permalink":"https://illuca.github.io/2023/12/28/118-Pascal-s-Triangle/","excerpt":"","text":"https://leetcode.cn/problems/pascals-triangle/?envType=study-plan-v2&amp;envId=top-100-liked 12345678910class Solution: def generate(self, numRows: int) -&gt; List[List[int]]: P=[] P.append([1]) for i in range(1,numRows): l=len(P[i-1])+1 P.append([1]*l) for j in range(1,l-1): P[i][j]=P[i-1][j-1]+P[i-1][j] return P","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"https://illuca.github.io/tags/easy/"},{"name":"DP","slug":"DP","permalink":"https://illuca.github.io/tags/DP/"}]},{"title":"70. Climbing Stairs","slug":"70-Climbing-Stairs","date":"2023-12-28T08:18:23.000Z","updated":"2024-01-09T04:43:20.865Z","comments":true,"path":"2023/12/28/70-Climbing-Stairs/","link":"","permalink":"https://illuca.github.io/2023/12/28/70-Climbing-Stairs/","excerpt":"","text":"https://leetcode.com/problems/climbing-stairs/ 12345678910111213class Solution: def climbStairs(self, n: int) -&gt; int: # i am climbing staircase # it has n steps # i can take 1 or 2 step each time # P(i) denotes the number of ways to reach i # P(i)=P(i-1)+P(i-2) P=[0]*(n+1) P[0]=1 P[1]=1 for i in range(2,n+1): P[i]=P[i-1]+P[i-2] return P[n]","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"https://illuca.github.io/tags/easy/"},{"name":"DP","slug":"DP","permalink":"https://illuca.github.io/tags/DP/"}]},{"title":"797. All Paths From Source to Target","slug":"797-All-Paths-From-Source-to-Target","date":"2023-12-28T07:28:34.000Z","updated":"2023-12-28T04:30:07.290Z","comments":true,"path":"2023/12/28/797-All-Paths-From-Source-to-Target/","link":"","permalink":"https://illuca.github.io/2023/12/28/797-All-Paths-From-Source-to-Target/","excerpt":"","text":"https://leetcode.com/problems/all-paths-from-source-to-target/ 123456789101112131415161718class Solution: def allPathsSourceTarget(self, G: List[List[int]]) -&gt; List[List[int]]: def f(start,curr): if start==N-1: Z.append(curr[:]) return for node in G[start]: curr.append(node) f(node,curr) curr.pop() if not G: return [] N=len(G) Z=[] f(0,[0]) return Z","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"backtrack","slug":"backtrack","permalink":"https://illuca.github.io/tags/backtrack/"},{"name":"grpah","slug":"grpah","permalink":"https://illuca.github.io/tags/grpah/"}]},{"title":"39. Combination Sum","slug":"39-Combination-Sum","date":"2023-12-27T10:25:04.000Z","updated":"2023-12-27T07:37:09.068Z","comments":true,"path":"2023/12/27/39-Combination-Sum/","link":"","permalink":"https://illuca.github.io/2023/12/27/39-Combination-Sum/","excerpt":"","text":"https://leetcode.com/problems/combination-sum/ This version does not consider if the given array has been sorted. But anyway, it passed all tests :P. 12345678910111213141516171819202122class Solution: def combinationSum(self, A: List[int], target: int) -&gt; List[List[int]]: def f(i,curr,W): if W&gt;target: return if W==target: Z.append(curr[:]) return if W&lt;target: for i in range(len(A)): if curr and A[i]&lt;curr[-1]: continue curr.append(A[i]) W+=A[i] f(i+1,curr,W) curr.pop() W-=A[i] Z=[] f(0,[],0) return Z This version is more correct: 12345678910111213141516171819202122class Solution: def combinationSum(self, A: List[int], target: int) -&gt; List[List[int]]: def f(start,curr,W): if W&gt;target: return if W==target: Z.append(curr[:]) return if W&lt;target: # give current index one more chance for i in range(start,len(A)): curr.append(A[i]) W+=A[i] f(i,curr,W) curr.pop() W-=A[i] Z=[] A.sort() f(0,[],0) return Z","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"backtrack","slug":"backtrack","permalink":"https://illuca.github.io/tags/backtrack/"},{"name":"combination","slug":"combination","permalink":"https://illuca.github.io/tags/combination/"}]},{"title":"17. Letter Combinations of a Phone Number","slug":"17-Letter-Combinations-of-a-Phone-Number","date":"2023-12-27T09:01:47.000Z","updated":"2023-12-27T06:10:48.501Z","comments":true,"path":"2023/12/27/17-Letter-Combinations-of-a-Phone-Number/","link":"","permalink":"https://illuca.github.io/2023/12/27/17-Letter-Combinations-of-a-Phone-Number/","excerpt":"","text":"https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/ 1234567891011121314151617181920212223242526class Solution: def letterCombinations(self, A: str) -&gt; List[str]: D=&#123; &#x27;2&#x27;: &quot;abc&quot;, &#x27;3&#x27;: &#x27;def&#x27;, &#x27;4&#x27;: &#x27;ghi&#x27;, &#x27;5&#x27;: &#x27;jkl&#x27;, &#x27;6&#x27;: &#x27;mno&#x27;, &#x27;7&#x27;: &#x27;pqrs&#x27;, &#x27;8&#x27;: &#x27;tuv&#x27;, &#x27;9&#x27;: &#x27;wxyz&#x27; &#125; def f(idx,curr): if len(curr)==len(A): Z.append(&quot;&quot;.join(curr)) return candidates=D[A[idx]] for candidate in candidates: curr.append(candidate) f(idx+1,curr) curr.pop() Z=[] if not A: return [] f(0,[]) return Z","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"backtrack","slug":"backtrack","permalink":"https://illuca.github.io/tags/backtrack/"},{"name":"combination","slug":"combination","permalink":"https://illuca.github.io/tags/combination/"}]},{"title":"78. Subsets","slug":"78-Subsets","date":"2023-12-26T12:43:51.000Z","updated":"2024-01-09T04:43:25.161Z","comments":true,"path":"2023/12/26/78-Subsets/","link":"","permalink":"https://illuca.github.io/2023/12/26/78-Subsets/","excerpt":"","text":"https://leetcode.com/problems/subsets/description/ Solution1: bottom up dp 1234567891011121314class Solution: def subsets(self, A: List[int]) -&gt; List[List[int]]: def f(idx): for i in range(len(Z)): Z.append(Z[i]+[A[idx]]) Z.append([A[idx]]) Z=[] S=[] A.sort() for i in range(len(A)): S.append(i) f(i) Z.append([]) return Z Solution2: backtrack 123456789101112131415class Solution: def subsets(self, A: List[int]) -&gt; List[List[int]]: def f(start,curr): if len(curr)==k: Z.append(curr[:]) return for i in range(start,len(A)): curr.append(A[i]) f(i+1,curr) curr.pop() Z=[] for k in range(len(A)+1): # length is from 0 to len(A) f(0,[]) return Z","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"DP","slug":"DP","permalink":"https://illuca.github.io/tags/DP/"},{"name":"sub","slug":"sub","permalink":"https://illuca.github.io/tags/sub/"},{"name":"backtrack","slug":"backtrack","permalink":"https://illuca.github.io/tags/backtrack/"}]},{"title":"207. Course Schedule","slug":"207-Course-Schedule","date":"2023-12-26T09:20:23.000Z","updated":"2024-01-09T04:46:25.882Z","comments":true,"path":"2023/12/26/207-Course-Schedule/","link":"","permalink":"https://illuca.github.io/2023/12/26/207-Course-Schedule/","excerpt":"","text":"123456789101112131415161718192021222324class Solution: def canFinish(self, N: int, G: List[List[int]]) -&gt; bool: IN=[0]*N OUT=[[]*N for _ in range(N)] for g in G: fst,snd=g IN[fst]+=1 OUT[snd].append(fst) Q=deque() seen=0 #find all nodes with indegree=0 and store them in Q for i in range(len(IN)): if IN[i]==0: Q.append(i) while Q: a=Q.popleft() seen+=1 for b in OUT[a]: IN[b]-=1 if IN[b]==0: Q.append(b) print(seen) return seen==N","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"DFS","slug":"DFS","permalink":"https://illuca.github.io/tags/DFS/"},{"name":"graph","slug":"graph","permalink":"https://illuca.github.io/tags/graph/"},{"name":"topological sort","slug":"topological-sort","permalink":"https://illuca.github.io/tags/topological-sort/"}]},{"title":"994. Rotting Oranges","slug":"994-Rotting-Oranges","date":"2023-12-25T15:47:45.000Z","updated":"2024-01-09T04:48:54.349Z","comments":true,"path":"2023/12/26/994-Rotting-Oranges/","link":"","permalink":"https://illuca.github.io/2023/12/26/994-Rotting-Oranges/","excerpt":"","text":"https://leetcode.com/problems/rotting-oranges/ 1234567891011121314151617181920212223242526class Solution: def orangesRotting(self, G: List[List[int]]) -&gt; int: def f(i,j,k): for x,y in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]: if 0&lt;=x&lt;M and 0&lt;=y&lt;N and G[x][y]==1: Q.append((x,y,k+1)) G[x][y]=0 M=len(G) N=len(G[0]) ans=0 Q=deque() for i in range(M): for j in range(N): if G[i][j]==2: Q.append((i,j,0)) while Q: i,j,k=Q.popleft() ans=max(ans,k) f(i,j,k) for i in range(M): for j in range(N): if G[i][j]==1: ans=-1 return ans","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"BFS","slug":"BFS","permalink":"https://illuca.github.io/tags/BFS/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"graph","slug":"graph","permalink":"https://illuca.github.io/tags/graph/"}]},{"title":"25. Reverse Nodes in k-Group","slug":"25-Reverse-Nodes-in-k-Group","date":"2023-12-25T10:36:24.000Z","updated":"2023-12-25T07:43:29.631Z","comments":true,"path":"2023/12/25/25-Reverse-Nodes-in-k-Group/","link":"","permalink":"https://illuca.github.io/2023/12/25/25-Reverse-Nodes-in-k-Group/","excerpt":"","text":"https://leetcode.com/problems/reverse-nodes-in-k-group/description/ Note: In reverse function, we cannot use p is not end.next to decide whether to break because during reverse, the node that end points to will be inserted after head. Since node of pointer end is changing its position, thus it won’t help us terminate the loop. 1234567891011121314151617181920212223242526272829303132333435363738class Solution: def reverseKGroup(self, H: Optional[ListNode], k: int) -&gt; Optional[ListNode]: def moveToHead(h,prev,p): prev.next=p.next p.next=h.next h.next=p def nextK(h): p=h counter=0 while p: p=p.next counter+=1 if counter&gt;=k: break return p def reverse(h,end): prev=h.next p=prev.next counter=1 while counter!=k: moveToHead(h,prev,p) p=prev.next counter+=1 return prev if H is None: return None dummy=ListNode(-1) dummy.next=H h=dummy while True: end=nextK(h) if end is None: break h=reverse(h,end) return dummy.next","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"linked list","slug":"linked-list","permalink":"https://illuca.github.io/tags/linked-list/"},{"name":"hard","slug":"hard","permalink":"https://illuca.github.io/tags/hard/"}]},{"title":"200. Number of Islands","slug":"200-Number-of-Islands","date":"2023-12-24T13:52:38.000Z","updated":"2024-01-09T04:46:33.208Z","comments":true,"path":"2023/12/25/200-Number-of-Islands/","link":"","permalink":"https://illuca.github.io/2023/12/25/200-Number-of-Islands/","excerpt":"","text":"https://leetcode.com/problems/number-of-islands/ Solution1: DFS 123456789101112131415161718class Solution: def numIslands(self, G: List[List[str]]) -&gt; int: def f(i,j): if 0&lt;=i&lt;M and 0&lt;=j&lt;N and G[i][j]==&#x27;1&#x27;: G[i][j]=&#x27;0&#x27; f(i-1,j) f(i+1,j) f(i,j-1) f(i,j+1) M=len(G) N=len(G[0]) ans=0 for i in range(M): for j in range(N): if G[i][j]==&#x27;1&#x27;: f(i,j) ans+=1 return ans Solution2: BFS 1234567891011121314151617181920212223class Solution: def numIslands(self, G: List[List[str]]) -&gt; int: def f(i,j): nonlocal Q,G for i,j in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]: if 0&lt;=i&lt;M and 0&lt;=j&lt;N and G[i][j]==&#x27;1&#x27;: G[i][j]=0 Q.append((i,j)) M=len(G) N=len(G[0]) ans=0 Q=deque() for i in range(M): for j in range(N): if G[i][j]==&#x27;1&#x27;: ans+=1 G[i][j]=&#x27;0&#x27; Q.append((i,j)) while Q: x,y=Q.popleft() f(x,y) return ans","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"BFS","slug":"BFS","permalink":"https://illuca.github.io/tags/BFS/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"DFS","slug":"DFS","permalink":"https://illuca.github.io/tags/DFS/"},{"name":"graph","slug":"graph","permalink":"https://illuca.github.io/tags/graph/"},{"name":"modify original data","slug":"modify-original-data","permalink":"https://illuca.github.io/tags/modify-original-data/"}]},{"title":"236. Lowest Common Ancestor of a Binary Tree","slug":"236-Lowest-Common-Ancestor-of-a-Binary-Tree-1","date":"2023-12-23T14:24:30.000Z","updated":"2024-01-09T04:46:28.746Z","comments":true,"path":"2023/12/24/236-Lowest-Common-Ancestor-of-a-Binary-Tree-1/","link":"","permalink":"https://illuca.github.io/2023/12/24/236-Lowest-Common-Ancestor-of-a-Binary-Tree-1/","excerpt":"","text":"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/ 1234567891011121314151617class Solution: def lowestCommonAncestor(self, R: &#x27;TreeNode&#x27;, p: &#x27;TreeNode&#x27;, q: &#x27;TreeNode&#x27;) -&gt; &#x27;TreeNode&#x27;: def f(C): nonlocal ans if C is None: return False if C: l=f(C.left) r=f(C.right) found=C==p or C==q if l+r+found&gt;=2: ans=C return found or l or r ans=None f(R) return ans Solution2: Disjoint set 123456789101112131415161718192021222324class Solution: def lowestCommonAncestor(self, R: &#x27;TreeNode&#x27;, p: &#x27;TreeNode&#x27;, q: &#x27;TreeNode&#x27;) -&gt; &#x27;TreeNode&#x27;: if R is None: return None A=[R] parent=&#123;R:None&#125; while True: if p in parent and q in parent: break C=A.pop() if C.left: A.append(C.left) parent[C.left]=C if C.right: A.append(C.right) parent[C.right]=C seen=set() while p: seen.add(p) p=parent[p] # (1) # find parent until parent has been seen in step (1) while q not in seen: q=parent[q] return q","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"tree","slug":"tree","permalink":"https://illuca.github.io/tags/tree/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"DFS","slug":"DFS","permalink":"https://illuca.github.io/tags/DFS/"}]},{"title":"437. Path Sum III","slug":"437-Path-Sum-III","date":"2023-12-23T08:45:03.000Z","updated":"2023-12-23T05:56:40.285Z","comments":true,"path":"2023/12/23/437-Path-Sum-III/","link":"","permalink":"https://illuca.github.io/2023/12/23/437-Path-Sum-III/","excerpt":"","text":"https://leetcode.com/problems/path-sum-iii/description/ It is simlar to https://leetcode.com/problems/subarray-sum-equals-k/description/ 1234567891011121314151617class Solution: def pathSum(self, R: Optional[TreeNode], T: int) -&gt; int: def f(C,S): nonlocal ans if C is None: return S+=C.val ans+=seen[S-T] seen[S]+=1 f(C.left,S) f(C.right,S) seen[S]-=1 ans=0 seen=defaultdict(int) seen[0]=1 f(R,0) return ans","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"tree","slug":"tree","permalink":"https://illuca.github.io/tags/tree/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"sub","slug":"sub","permalink":"https://illuca.github.io/tags/sub/"},{"name":"prefix sum","slug":"prefix-sum","permalink":"https://illuca.github.io/tags/prefix-sum/"}]},{"title":"105. Construct Binary Tree from Preorder and Inorder Traversal","slug":"105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal","date":"2023-12-21T13:55:47.000Z","updated":"2024-01-09T04:46:43.704Z","comments":true,"path":"2023/12/22/105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/","link":"","permalink":"https://illuca.github.io/2023/12/22/105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/","excerpt":"","text":"https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/ Solution1: dfs 1234567891011121314151617181920class Solution: def buildTree(self, A: List[int], B: List[int]) -&gt; Optional[TreeNode]: def f(l,r): nonlocal idx if l&gt;r: return None root=TreeNode(A[idx]) idx+=1 root.left=f(l,BI[root.val]-1) root.right=f(BI[root.val]+1,r) return root if A is None or B is None: return None BI=&#123;&#125; idx=0 for i in range(len(A)): BI[B[i]]=i return f(0,len(A)-1) This version is easier to understand: 12345678910111213141516class Solution: def buildTree(self, A: List[int], B: List[int]) -&gt; Optional[TreeNode]: def f(l1,r1, l2,r2): if l1&gt;r1: return None root=TreeNode(A[l1]) lsize=BI[root.val]-l2 root.left=f(l1+1,l1+lsize, l2,BI[root.val]-1) root.right=f(l1+lsize+1,r1, BI[root.val]+1,r2) return root BI=&#123;&#125; for i in range(len(A)): BI[B[i]]=i return f(0,len(A)-1,0,len(B)-1)","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"tree","slug":"tree","permalink":"https://illuca.github.io/tags/tree/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"DFS","slug":"DFS","permalink":"https://illuca.github.io/tags/DFS/"},{"name":"inorder","slug":"inorder","permalink":"https://illuca.github.io/tags/inorder/"}]},{"title":"114. Flatten Binary Tree to Linked List","slug":"114-Flatten-Binary-Tree-to-Linked-List","date":"2023-12-21T09:07:48.000Z","updated":"2024-01-09T04:46:19.388Z","comments":true,"path":"2023/12/21/114-Flatten-Binary-Tree-to-Linked-List/","link":"","permalink":"https://illuca.github.io/2023/12/21/114-Flatten-Binary-Tree-to-Linked-List/","excerpt":"","text":"Solution1: DFS + store all nodes with space complexity O(n): 1234567891011121314class Solution: def flatten(self, R: Optional[TreeNode]) -&gt; None: def f(C): if C is None: return ans.append(C) f(C.left) f(C.right) ans=[] f(R) for i in range(1,len(ans)): ans[i-1].right=ans[i] ans[i-1].left=None Solution2: DFS with space complexity O(1): 1234567891011121314151617181920class Solution: def flatten(self, R: Optional[TreeNode]) -&gt; None: def f(C): if C is None: return None,None if C.left is None and C.right is None: return C,C if C.left is None: return C,f(C.right)[1] if C.right is None: C.right=C.left C.left=None return C,f(C.right)[1] if C.left and C.right: left,last=f(C.left) last.right=C.right C.right=left C.left=None return C,f(last.right)[1] f(R) It is similar to Haskell pattern match.","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"tree","slug":"tree","permalink":"https://illuca.github.io/tags/tree/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"DFS","slug":"DFS","permalink":"https://illuca.github.io/tags/DFS/"}]},{"title":"199. Binary Tree Right Side View","slug":"199-Binary-Tree-Right-Side-View","date":"2023-12-21T07:11:18.000Z","updated":"2024-01-09T04:46:40.531Z","comments":true,"path":"2023/12/21/199-Binary-Tree-Right-Side-View/","link":"","permalink":"https://illuca.github.io/2023/12/21/199-Binary-Tree-Right-Side-View/","excerpt":"","text":"https://leetcode.com/problems/binary-tree-right-side-view/ Solution1: recursive DFS 123456789101112131415class Solution: def __init__(self): self.k=-1 def rightSideView(self, R: Optional[TreeNode]) -&gt; List[int]: def f(C,k): if not C: return if k&gt;self.k: self.k+=1 ans.append(C.val) f(C.right,k+1) f(C.left,k+1) ans=[] f(R,0) return ans Solution2: BFS(one queue + traverse current level by storing length) 123456789101112131415161718class Solution: def rightSideView(self, R: Optional[TreeNode]) -&gt; List[int]: if not R: return [] Q=deque([R]) ans=[] while Q: L=len(Q) for i in range(L): C=Q.popleft() if i==L-1: # it is the right most node in current level ans.append(C.val) if C.left: Q.append(C.left) if C.right: Q.append(C.right) return ans Solution3: BFS(one queue + None sentinel) 12345678910111213141516171819class Solution: def rightSideView(self, R: Optional[TreeNode]) -&gt; List[int]: if not R: return [] Q=deque([R,None]) ans=[] while Q: C=Q.popleft() while C is not None: if C.left is not None: Q.append(C.left) if C.right is not None: Q.append(C.right) prev=C C=Q.popleft() ans.append(prev.val) if len(Q)&gt;0: Q.append(None) return ans Solution4: BFS(double queue) 12345678910111213141516171819202122232425262728293031323334353637class Solution: def rightSideView(self, R: Optional[TreeNode]) -&gt; List[int]: if R is None: return [] Q=deque([R]) ans=[] while Q: N=deque() ans.append(Q[-1].val) while Q: C=Q.popleft() if C.left: N.append(C.left) if C.right: N.append(C.right) Q=N return ans # orclass Solution: def rightSideView(self, R: Optional[TreeNode]) -&gt; List[int]: if R is None: return [] Q=deque([R]) ans=[] while Q: N=deque() while Q: C=Q.popleft() if C.left: N.append(C.left) if C.right: N.append(C.right) #last poped node is the right most node ans.append(C.val) Q=N return ans","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"tree","slug":"tree","permalink":"https://illuca.github.io/tags/tree/"},{"name":"BFS","slug":"BFS","permalink":"https://illuca.github.io/tags/BFS/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"DFS","slug":"DFS","permalink":"https://illuca.github.io/tags/DFS/"}]},{"title":"230. Kth Smallest Element in a BST","slug":"230-Kth-Smallest-Element-in-a-BST","date":"2023-12-20T15:07:14.000Z","updated":"2023-12-20T12:18:16.078Z","comments":true,"path":"2023/12/21/230-Kth-Smallest-Element-in-a-BST/","link":"","permalink":"https://illuca.github.io/2023/12/21/230-Kth-Smallest-Element-in-a-BST/","excerpt":"","text":"https://leetcode.com/problems/kth-smallest-element-in-a-bst/ 12345678910111213141516class Solution: def __init__(self): self.k=0 def kthSmallest(self, R: Optional[TreeNode], k: int) -&gt; int: def f(C): if not C: return -1 l=f(C.left) if l!=-1: return l # left not found self.k+=1 if self.k==k: return C.val return f(C.right) return f(R) It can be improved to deal with node with negative values: 12345678910111213141516class Solution: def __init__(self): self.k=0 def kthSmallest(self, R: Optional[TreeNode], k: int) -&gt; int: def f(C): if not C: return C l=f(C.left) if l: return l # left not found self.k+=1 if self.k==k: return C return f(C.right) return f(R).val","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"tree","slug":"tree","permalink":"https://illuca.github.io/tags/tree/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"inorder","slug":"inorder","permalink":"https://illuca.github.io/tags/inorder/"}]},{"title":"98. Validate Binary Search Tree","slug":"98-Validate-Binary-Search-Tree","date":"2023-12-20T13:27:24.000Z","updated":"2024-01-09T04:54:38.767Z","comments":true,"path":"2023/12/21/98-Validate-Binary-Search-Tree/","link":"","permalink":"https://illuca.github.io/2023/12/21/98-Validate-Binary-Search-Tree/","excerpt":"","text":"https://leetcode.com/problems/validate-binary-search-tree/ Solution1: inorder traverse and store all values in array 1234567891011121314151617class Solution: def __init__(self): self.V=[] def isValidBST(self, R: Optional[TreeNode]) -&gt; bool: def f(C): if not C: return f(C.left) self.V.append(C.val) f(C.right) f(R) for i in range(1,len(self.V)): if self.V[i-1]&lt;self.V[i]: continue else: return False return True Solution2: recursive DFS 123456789101112131415161718192021222324class Solution: def isValidBST(self,R: Optional[TreeNode]) -&gt; bool: def f(C,m,M): if not C: return True if m and m.val&gt;=C.val: return False if M and M.val&lt;=C.val: return False return f(C.left,m,C) and f(C.right,C,M) return f(R,None,None) class Solution: def isValidBST(self,R: Optional[TreeNode]) -&gt; bool: def f(C,m,M): if not C: return True if m&gt;=C.val: return False if M&lt;=C.val: return False return f(C.left,m,C.val) and f(C.right,C.val,M) return f(R,-math.inf,M=math.inf) Solution 3: iterative DFS 1234567891011121314class Solution: def isValidBST(self,R: Optional[TreeNode]) -&gt; bool: if not R: return True S=[(R,-math.inf,math.inf)] while S: C,m,M=S.pop() if m&gt;=C.val or C.val&gt;=M: return False if C.left: S.append((C.left,m,C.val)) if C.right: S.append((C.right,C.val,M)) return True Solution4: recursive inorder 123456789101112131415class Solution: def __init__(self): self.prev=None def isValidBST(self,R: Optional[TreeNode]) -&gt; bool: def f(C): if not C: return True if f(C.left) and C.val&gt;self.prev: # ^ current &gt; left self.prev=C.val return f(C.right) else: return False self.prev=-math.inf return f(R) Solution5: iterative inorder 1234567891011121314151617181920212223242526272829303132333435363738class Solution: def isValidBST(self,R: Optional[TreeNode]) -&gt; bool: S=[] prev=-math.inf C=R while S or C: while C: S.append(C) C=C.left if not C: C=S.pop() if prev&gt;=C.val: return False prev=C.val C=C.right return True class Solution: def isValidBST(self,R: Optional[TreeNode]) -&gt; bool: prev=-math.inf C=R if not C: return True S=[] while True: while C: S.append(C) C=C.left if not C and not S: break if not C: C=S.pop() if prev&gt;=C.val: return False prev=C.val C=C.right return True","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"DFS","slug":"DFS","permalink":"https://illuca.github.io/tags/DFS/"},{"name":"inorder","slug":"inorder","permalink":"https://illuca.github.io/tags/inorder/"},{"name":"BST","slug":"BST","permalink":"https://illuca.github.io/tags/BST/"}]},{"title":"102. Binary Tree Level Order Traversal","slug":"102-Binary-Tree-Level-Order-Traversal","date":"2023-12-19T14:25:00.000Z","updated":"2024-01-09T04:48:51.745Z","comments":true,"path":"2023/12/20/102-Binary-Tree-Level-Order-Traversal/","link":"","permalink":"https://illuca.github.io/2023/12/20/102-Binary-Tree-Level-Order-Traversal/","excerpt":"","text":"S1: Recursion: 123456789101112131415class Solution: def levelOrder(self, R: Optional[TreeNode]) -&gt; List[List[int]]: def f(r,k): if len(ans)==k: ans.append([]) #newline ans[k].append(r.val) if r.left: f(r.left,k+1) if r.right: f(r.right,k+1) if not R: return [] ans=[] f(R,0) return ans S1: Iteration 1234567891011121314151617from collections import dequeclass Solution: def levelOrder(self, R: Optional[TreeNode]) -&gt; List[List[int]]: if not R: return [] Q=deque([(R,0)]) ans=[] while len(Q)&gt;0: C,k=Q.popleft() if len(ans)==k: ans.append([]) ans[k].append(C.val) if C.left: Q.append((C.left,k+1)) if C.right: Q.append((C.right,k+1)) return ans 123456789101112131415161718class Solution: def levelOrder(self, R: Optional[TreeNode]) -&gt; List[List[int]]: if not R: return [] Q=deque([R]) ans=[] k=0 while len(Q)&gt;0: ans.append([]) for i in range(len(Q)): C=Q.popleft() ans[k].append(C.val) if C.left: Q.append(C.left) if C.right: Q.append(C.right) k+=1 return ans","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"tree","slug":"tree","permalink":"https://illuca.github.io/tags/tree/"},{"name":"BFS","slug":"BFS","permalink":"https://illuca.github.io/tags/BFS/"}]},{"title":"73. Set Matrix Zeroes","slug":"73-Set-Matrix-Zeroes","date":"2023-12-19T10:24:05.000Z","updated":"2023-12-19T07:27:46.321Z","comments":true,"path":"2023/12/19/73-Set-Matrix-Zeroes/","link":"","permalink":"https://illuca.github.io/2023/12/19/73-Set-Matrix-Zeroes/","excerpt":"","text":"1234567891011121314151617181920212223242526272829class Solution: def setZeroes(self, A: List[List[int]]) -&gt; None: M=len(A) N=len(A[0]) r0=False c0=False for i in range(M): for j in range(N): if A[i][j]==0: A[i][0]=0 A[0][j]=0 if i==0: r0=True if j==0: c0=True for i in range(1,M): if A[i][0]==0: for j in range(N): A[i][j]=0 for j in range(1,N): if A[0][j]==0: for i in range(M): A[i][j]=0 if r0: for j in range(N): A[0][j]=0 if c0: for i in range(M): A[i][0]=0","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"array","slug":"array","permalink":"https://illuca.github.io/tags/array/"},{"name":"space complexity","slug":"space-complexity","permalink":"https://illuca.github.io/tags/space-complexity/"},{"name":"matrix","slug":"matrix","permalink":"https://illuca.github.io/tags/matrix/"}]},{"title":"238. Product of Array Except Self","slug":"238-Product-of-Array-Except-Self","date":"2023-12-19T09:05:28.000Z","updated":"2023-12-19T06:16:45.363Z","comments":true,"path":"2023/12/19/238-Product-of-Array-Except-Self/","link":"","permalink":"https://illuca.github.io/2023/12/19/238-Product-of-Array-Except-Self/","excerpt":"","text":"method1: division 1234567891011121314151617181920212223class Solution: def productExceptSelf(self, A: List[int]) -&gt; List[int]: P=1 N=len(A) k=0 for i in range(N): if A[i]==0: k+=1 else: P=P*A[i] ans=[0]*N for i in range(N): if k&gt;=2: P=0 elif k==1: print(A[i]) if A[i]==0: ans[i]=P else: ans[i]=0 else: ans[i]=P//A[i] return ans method2: hash: space O(n) without division 12345678910111213141516171819202122class Solution: def productExceptSelf(self, A: List[int]) -&gt; List[int]: L=&#123;&#125; R=&#123;&#125; N=len(A) ans=[0]*N P=1 for i in range(N): P=P*A[i] L[i]=P P=1 for i in range(N-1,-1,-1): P=P*A[i] R[i]=P for i in range(N): curr=1 if i-1&gt;=0: curr*=L[i-1] if i+1&lt;N: curr*=R[i+1] ans[i]=curr return ans method3: improve the method 2 123456789101112131415161718class Solution: def productExceptSelf(self, A: List[int]) -&gt; List[int]: N=len(A) ans=[0]*N LP=1 for i in range(N): LP*=A[i] ans[i]=LP RP=1 for i in range(N-1,-1,-1): #right part curr=RP RP*=A[i] #left part if i-1&gt;=0: curr*=ans[i-1] ans[i]=curr return ans","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"hash","slug":"hash","permalink":"https://illuca.github.io/tags/hash/"},{"name":"array","slug":"array","permalink":"https://illuca.github.io/tags/array/"}]},{"title":"189. Rotate Array","slug":"189-Rotate-Array","date":"2023-12-19T06:43:45.000Z","updated":"2023-12-19T04:50:55.052Z","comments":true,"path":"2023/12/19/189-Rotate-Array/","link":"","permalink":"https://illuca.github.io/2023/12/19/189-Rotate-Array/","excerpt":"","text":"https://leetcode.com/problems/rotate-array/ 1234567891011121314class Solution: def rotate(self, A: List[int], k: int) -&gt; None: #reverse the whole N=len(A) k=k%N for i in range(N//2): A[i],A[N-1-i]=A[N-1-i],A[i] #reverse [0:k] for i in range(k//2): A[i],A[k-1-i]=A[k-1-i],A[i] #reverse [k:] for i in range((N-k)//2): A[k+i],A[N-1-i]=A[N-1-i],A[k+i] It can be simplified: 123456789101112131415class Solution: def rotate(self, A: List[int], k: int) -&gt; None: def reverse(i,j): while i&lt;j: A[i],A[j]=A[j],A[i] i,j=i+1,j-1 N=len(A) k=k%N #reverse the whole reverse(0,N-1) #reverse first k reverse(0,k-1) #reverse last k reverse(k,N-1)","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"sub","slug":"sub","permalink":"https://illuca.github.io/tags/sub/"},{"name":"array","slug":"array","permalink":"https://illuca.github.io/tags/array/"}]},{"title":"53. Maximum Subarray","slug":"53-Maximum-Subarray","date":"2023-12-18T14:32:15.000Z","updated":"2024-01-09T04:43:18.115Z","comments":true,"path":"2023/12/19/53-Maximum-Subarray/","link":"","permalink":"https://illuca.github.io/2023/12/19/53-Maximum-Subarray/","excerpt":"","text":"https://leetcode.com/problems/maximum-subarray/editorial/ 12345678910111213class Solution: def maxSubArray(self, A: List[int]) -&gt; int: if not A: return 0 N=len(A) S=0 M=float(&#x27;-inf&#x27;) for i in range(N): S+=A[i] M=max(M,S) if S&lt;0: S=0 return M divide and conquer 12345678910111213141516171819202122class Solution: def maxSubArray(self, A: List[int]) -&gt; int: def f(l,r): if l&gt;r: return -math.inf mid=(l+r)//2 lmax=0 curr=0 for i in range(mid-1,l-1,-1): curr+=A[i] lmax=max(curr,lmax) rmax=0 curr=0 for i in range(mid+1,r+1): curr+=A[i] rmax=max(curr,rmax) curr=lmax+rmax+A[mid] left=f(l,mid-1) right=f(mid+1,r) return max(curr,left,right) return f(0,len(A)-1)","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"DP","slug":"DP","permalink":"https://illuca.github.io/tags/DP/"},{"name":"sub","slug":"sub","permalink":"https://illuca.github.io/tags/sub/"},{"name":"array","slug":"array","permalink":"https://illuca.github.io/tags/array/"},{"name":"divide and conquer","slug":"divide-and-conquer","permalink":"https://illuca.github.io/tags/divide-and-conquer/"}]},{"title":"560. Subarray Sum Equals K","slug":"560-Subarray-Sum-Equals-K","date":"2023-12-17T14:17:09.000Z","updated":"2024-05-03T13:51:30.054Z","comments":true,"path":"2023/12/18/560-Subarray-Sum-Equals-K/","link":"","permalink":"https://illuca.github.io/2023/12/18/560-Subarray-Sum-Equals-K/","excerpt":"","text":"12345678910111213class Solution: def subarraySum(self, A: List[int], k: int) -&gt; int: N=len(A) D=defaultdict(int) S=0 ans=0 D[0]=1 for i in range(N): S+=A[i] if S-k in D: ans+=D[S-k] D[S]+=1 return ans","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"sub","slug":"sub","permalink":"https://illuca.github.io/tags/sub/"},{"name":"hash","slug":"hash","permalink":"https://illuca.github.io/tags/hash/"},{"name":"array","slug":"array","permalink":"https://illuca.github.io/tags/array/"},{"name":"prefix sum","slug":"prefix-sum","permalink":"https://illuca.github.io/tags/prefix-sum/"}]},{"title":"438. Find All Anagrams in a String","slug":"438-Find-All-Anagrams-in-a-String","date":"2023-12-16T15:08:46.000Z","updated":"2023-12-19T02:47:46.895Z","comments":true,"path":"2023/12/17/438-Find-All-Anagrams-in-a-String/","link":"","permalink":"https://illuca.github.io/2023/12/17/438-Find-All-Anagrams-in-a-String/","excerpt":"","text":"123456789101112131415class Solution: def findAnagrams(self, s: str, p: str) -&gt; List[int]: cp=Counter(p) cs=defaultdict(int) ret=[] for i in range(len(s)): cs[s[i]]+=1 if i&gt;=len(p): cs[s[i-len(p)]]-=1 if cs[s[i-len(p)]]==0: del cs[s[i-len(p)]] if cs==cp: ret.append(i-len(p)+1) return ret","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"string","slug":"string","permalink":"https://illuca.github.io/tags/string/"},{"name":"hash","slug":"hash","permalink":"https://illuca.github.io/tags/hash/"},{"name":"pattern match","slug":"pattern-match","permalink":"https://illuca.github.io/tags/pattern-match/"}]},{"title":"42. Trapping Rain Water","slug":"42-Trapping-Rain-Water","date":"2023-12-16T15:08:01.000Z","updated":"2024-01-09T04:46:49.762Z","comments":true,"path":"2023/12/17/42-Trapping-Rain-Water/","link":"","permalink":"https://illuca.github.io/2023/12/17/42-Trapping-Rain-Water/","excerpt":"","text":"12345678910111213141516171819class Solution: def trap(self, A: List[int]) -&gt; int: N=len(A) L=[0]*N M=0 for i in range(N): M=max(M,A[i]) L[i]=M R=[0]*N M=0 for i in range(N-1,-1,-1): M=max(M,A[i]) R[i]=M ret=0 for i in range(1,len(A)): LM=L[i] RM=R[i] ret+=min(LM,RM)-A[i] return ret","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"DP","slug":"DP","permalink":"https://illuca.github.io/tags/DP/"},{"name":"hard","slug":"hard","permalink":"https://illuca.github.io/tags/hard/"}]},{"title":"15. 3Sum","slug":"15-3Sum","date":"2023-12-15T11:22:05.000Z","updated":"2023-12-15T08:32:55.616Z","comments":true,"path":"2023/12/15/15-3Sum/","link":"","permalink":"https://illuca.github.io/2023/12/15/15-3Sum/","excerpt":"","text":"https://leetcode.com/problems/3sum/editorial/ 12345678910111213141516171819202122232425262728293031323334from collections import Counterclass Solution: def threeSum(self, A: List[int]) -&gt; List[List[int]]: if not A: return [] N=len(A) D=&#123;&#125; S=set() A.sort() k=1 B=[A[0]] for i in range(1,N): if A[i]==A[i-1]: k+=1 else: k=1 if k&lt;=2 or k&lt;=3 and A[i]==0: B.append(A[i]) A=B N=len(A) for i,a in enumerate(A): D[a]=i for i in range(N): for j in range(i+1,N): C=-(A[i]+A[j]) # complement if C in D and D[C]!=i and D[C]!=j: S.add(tuple(sorted([A[i],A[j],C]))) ret=[] for l in S: ret.append(l) return ret","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"}]},{"title":"128. Longest Consecutive Sequence","slug":"128-Longest-Consecutive-Sequence","date":"2023-12-15T10:02:52.000Z","updated":"2023-12-15T07:03:55.093Z","comments":true,"path":"2023/12/15/128-Longest-Consecutive-Sequence/","link":"","permalink":"https://illuca.github.io/2023/12/15/128-Longest-Consecutive-Sequence/","excerpt":"","text":"https://leetcode.com/problems/longest-consecutive-sequence/ 12345678910111213141516171819202122class Solution: def longestConsecutive(self, A: List[int]) -&gt; int: if not A: return 0 S=set(A) M=1 for a in A: if a in S: S.discard(a) k=1 i=1 while a+i in S: k+=1 S.discard(a+i) i+=1 i=1 while a-i in S: k+=1 S.discard(a-i) i+=1 M=max(M,k) return M It can be simplified: 123456789101112131415class Solution: def longestConsecutive(self, A: List[int]) -&gt; int: if not A: return 0 S=set(A) M=1 for a in S: if a-1 not in S: k=1 i=1 while a+i in S: k+=1 i+=1 M=max(M,k) return M","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"greedy","slug":"greedy","permalink":"https://illuca.github.io/tags/greedy/"}]},{"title":"47. Permutations II","slug":"47-Permutations-II","date":"2023-12-14T14:12:33.000Z","updated":"2023-12-14T11:38:08.631Z","comments":true,"path":"2023/12/15/47-Permutations-II/","link":"","permalink":"https://illuca.github.io/2023/12/15/47-Permutations-II/","excerpt":"","text":"1234567891011121314151617181920212223242526from collections import Counterclass Solution: def permuteUnique(self, A: List[int]) -&gt; List[List[int]]: def backtrack(l): if len(l)==N: ret.append(l[:]) return S=set() for a in A: if a not in S: S.add(a) if C[a]!=0: C[a]-=1 l.append(a) backtrack(l) l.pop() C[a]+=1 if not A: return [] N=len(A) C=Counter(A) print(C) ret=[] backtrack([]) return ret 12345678910111213141516171819202122232425262728from collections import Counterclass Solution: def permuteUnique(self, A: List[int]) -&gt; List[List[int]]: def f(l,a): i=0 res=[] while i&lt;=len(l): new=l[:i]+[a]+l[i:] if new not in newll and new not in res: print(new) res.append(new) if i&lt;len(l) and l[i]==a: i+=2 else: i+=1 return res ll=[[]] A.sort() N=len(A) for a in A: newll=[] for l in ll: newll.extend(f(l,a)) # print(newll) ll=newll return ll","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"backtrack","slug":"backtrack","permalink":"https://illuca.github.io/tags/backtrack/"}]},{"title":"31. Next Permutation","slug":"31-Next-Permutation","date":"2023-12-14T10:57:18.000Z","updated":"2023-12-14T07:57:57.948Z","comments":true,"path":"2023/12/14/31-Next-Permutation/","link":"","permalink":"https://illuca.github.io/2023/12/14/31-Next-Permutation/","excerpt":"","text":"https://leetcode.com/problems/next-permutation/description/ 1234567891011121314151617181920212223class Solution: def nextPermutation(self, A: List[int]) -&gt; None: def reverse(start): i=start j=N-1 while i&lt;j: A[i],A[j]=A[j],A[i] i+=1 j-=1 N=len(A) i=N-2 while i&gt;=0 and A[i]&gt;=A[i+1]: i-=1 if i&gt;=0: j=N-1 while j&gt;=0 and A[j]&lt;=A[i]: j-=1 # k∈[j,N-1],A[k]&lt;=A[i] # thus A[j]&lt;=A[i], thus after swap, it is still sorted A[i],A[j]=A[j],A[i] reverse(i+1) else: reverse(i+1)","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"}]},{"title":"72. Edit Distance","slug":"72-Edit-Distance","date":"2023-12-09T11:33:14.000Z","updated":"2024-01-09T04:43:36.823Z","comments":true,"path":"2023/12/09/72-Edit-Distance/","link":"","permalink":"https://illuca.github.io/2023/12/09/72-Edit-Distance/","excerpt":"","text":"https://leetcode.com/problems/edit-distance/ Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2. You have the following three operations permitted on a word: Insert a character Delete a character Replace a character Example 1: 123456Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;Output: 3Explanation: horse -&gt; rorse (replace &#x27;h&#x27; with &#x27;r&#x27;)rorse -&gt; rose (remove &#x27;r&#x27;)rose -&gt; ros (remove &#x27;e&#x27;) Example 2: 12345678Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;Output: 5Explanation: intention -&gt; inention (remove &#x27;t&#x27;)inention -&gt; enention (replace &#x27;i&#x27; with &#x27;e&#x27;)enention -&gt; exention (replace &#x27;n&#x27; with &#x27;x&#x27;)exention -&gt; exection (replace &#x27;n&#x27; with &#x27;c&#x27;)exection -&gt; execution (insert &#x27;u&#x27;) Constraints: 0 &lt;= word1.length, word2.length &lt;= 500 word1 and word2 consist of lowercase English letters Let P[i][j] denote the cost of transforming a[0..i-1] to b[0..j-1].For current operation, we have several choices. Assume we have solved P[i-1][j-1], P[i-1][j], P[i][j-1]. Now we try to solve P[i][j].if current operation is delete, then we must have transformed a[0..i-2] to b[0..j-1]if current operation is insert, then we must have transformed a[0..i-1] to b[0..j-2]Otherwise, then we have transformed a[0..i-1] to b[0..j-1].If a[i-1]=b[j-1], then current operation is do nothing.If a[i-1]!=b[j-1], then current operation is replacement. Thus for i∈[1,n], j∈[1,m], we have$$P[i][j]=\\begin{cases} P[i-1][j]+1 &amp; \\ P[i][j-1]+1 &amp; \\ P[i-1][j-1] &amp; a[i-1]=b[j-1] \\ P[i-1][j-1]+1 &amp; a[i-1]!=b[j-1]\\end{cases}$$ Base cases: The cost of transforming a[0..i-1] to empty string is always doing deletion i times . Thus P[i][0]=i The cost of transforming emtpy string to b[0..j-1] is always doing insertion j times. Thus P[0][j]=j Order of Computation and Final Solution Before we solve P[i][j], we need to solve P[i-1][j],P[i][j-1],P[i][j], thus the order should be increasing order of i and j. The final solution is P[n][m] Time Complexity There are n*m subproblems, thus the time complexity is O(nm). 12345678910111213141516171819202122232425262728293031class Solution: def minDistance(self, a: str, b: str) -&gt; int: n=len(a) m=len(b) P=[[0]*(m+1) for _ in range(n+1)] if m==0: return n if n==0: return m for i in range(1,n+1): P[i][0]=i for j in range(1,m+1): P[0][j]=j for i in range(1,n+1): for j in range(1,m+1): if a[i-1]==b[j-1]: P[i][j]=min( P[i-1][j]+1, #delete P[i][j-1]+1, #insert P[i-1][j-1] ) else: P[i][j]=min( P[i-1][j]+1, P[i][j-1]+1, P[i-1][j-1]+1 #replace ) return P[n][m]","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"DP","slug":"DP","permalink":"https://illuca.github.io/tags/DP/"}]},{"title":"23. Merge k Sorted Lists","slug":"23-Merge-k-Sorted-Lists","date":"2023-11-07T17:58:49.000Z","updated":"2023-11-07T14:59:47.673Z","comments":true,"path":"2023/11/08/23-Merge-k-Sorted-Lists/","link":"","permalink":"https://illuca.github.io/2023/11/08/23-Merge-k-Sorted-Lists/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: &quot;&quot;&quot; create a list ans. create a array A. A[i] stores the pointer of lists[i] create a priority queue named Q. For each pointer i in A, we add A[i].val to Q. While Q is not empty, do: get pointer i and value x from Q, add x to res after move forward the pointer i, if i is not null, then add i&#x27;.val, i&#x27; to Q. &quot;&quot;&quot; def mergeKLists(self, lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]: A,Q=[],[] ans=ListNode() w=ans for p in lists: if p is not None: A.append(p) for i,p in enumerate(A): heapq.heappush(Q,(p.val,i,p)) while len(Q) &gt; 0: x,i,p=heapq.heappop(Q) w.next=ListNode(x) w=w.next p=p.next if p is not None: heapq.heappush(Q,(p.val,i,p)) return ans.next","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"hard","slug":"hard","permalink":"https://illuca.github.io/tags/hard/"}]},{"title":"46. Permutations","slug":"46-Permutations","date":"2023-11-07T16:43:47.000Z","updated":"2023-11-07T15:07:18.725Z","comments":true,"path":"2023/11/08/46-Permutations/","link":"","permalink":"https://illuca.github.io/2023/11/08/46-Permutations/","excerpt":"","text":"123456789101112131415161718192021222324252627class Solution: &quot;&quot;&quot; create a 3D array dp. let dp[i] denote the permutations with first i elements. denote size of nums as N so dp[N] stores the permutations with first N elements. basic: dp[0]=[[-1]] dp[1]=[[nums[0]]] &quot;&quot;&quot; def permute(self, nums: List[int]) -&gt; List[List[int]]: def insert(l,curr)-&gt;List[List]: res=[] for i in range(len(l)+1): res.append(l[:i]+[curr]+l[i:]) return res N=len(nums) dp=[[[-1]],[[nums[0]]]] for i in range(1,N): curr=nums[i] tmp=[] for l in dp[i]: newE:List[List] = insert(l, curr) tmp.extend(newE) dp.append(tmp) return dp[N] 12345678910111213141516171819202122232425262728293031class Solution: def permute(self, nums: List[int]) -&gt; List[List[int]]: &quot;&quot;&quot; first ans is empty for backtrack, start from [], for each item in nums, we add it to the end of curr, then do backtrack each item corresponds to a function call [1] -&gt; [1,2] -&gt; [1,2,3] -&gt; [1,3] -&gt; [1,3,2] [2] -&gt; [2,1] -&gt; [2,1,3] -&gt; [2,3] -&gt; [2,3,1] [3] -&gt; [3,1] -&gt; [3,1,2] -&gt; [3,2] -&gt; [3,2,1] for each call, we do iteration for nums, so it costs O(n) during iteration, for each item, we call backtrack, so there are O(n) backtrack &quot;&quot;&quot; def backtrack(curr): nonlocal ans if len(curr) == len(nums): ans.append(curr[:]) return for num in nums: if num not in curr: curr.append(num) backtrack(curr) curr.pop() ans = [] backtrack([]) return ans","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"}]},{"title":"Greedy--Candies","slug":"Greedy-Candies","date":"2023-06-29T10:46:40.000Z","updated":"2023-11-02T09:32:09.160Z","comments":true,"path":"2023/06/29/Greedy-Candies/","link":"","permalink":"https://illuca.github.io/2023/06/29/Greedy-Candies/","excerpt":"","text":"https://www.hackerrank.com/challenges/candies/problem 12345678910111213141516171819202122232425262728long candies(int n, vector&lt;int&gt; arr) &#123; if(arr.empty())&#123; return 0; &#125; vector&lt;int&gt; candies(n); int curr=1; candies[0]=1; for(int i=0;i+1&lt;n;i++)&#123; if(arr[i+1]&gt;arr[i])&#123; curr++; &#125;else&#123; curr=1; &#125; candies[i+1]=curr; &#125; // deal with case like: [5,5,4,3,2] for(int i=n-1;i&gt;=1;i--)&#123; if(arr[i-1]&gt;arr[i] &amp;&amp; candies[i-1]&lt;=candies[i])&#123; candies[i-1]=candies[i]+1; &#125; &#125; long total=0; for(int i=0;i&lt;n;i++)&#123; total+=candies[i]; &#125; return total;&#125;","categories":[],"tags":[{"name":"greedy","slug":"greedy","permalink":"https://illuca.github.io/tags/greedy/"},{"name":"hankerrank","slug":"hankerrank","permalink":"https://illuca.github.io/tags/hankerrank/"}]},{"title":"2244. Minimum Rounds to Complete All Tasks","slug":"2244-Minimum-Rounds-to-Complete-All-Tasks-1","date":"2023-06-29T06:57:20.000Z","updated":"2023-11-02T09:25:01.505Z","comments":true,"path":"2023/06/29/2244-Minimum-Rounds-to-Complete-All-Tasks-1/","link":"","permalink":"https://illuca.github.io/2023/06/29/2244-Minimum-Rounds-to-Complete-All-Tasks-1/","excerpt":"","text":"You are given a 0-indexed integer array tasks, where tasks[i] represents the difficulty level of a task. In each round, you can complete either 2 or 3 tasks of the same difficulty level. Return the minimum rounds required to complete all the tasks, or -1 if it is not possible to complete all the tasks. Example 1: 12345678Input: tasks = [2,2,3,3,2,4,4,4,4,4]Output: 4Explanation: To complete all the tasks, a possible plan is:- In the first round, you complete 3 tasks of difficulty level 2. - In the second round, you complete 2 tasks of difficulty level 3. - In the third round, you complete 3 tasks of difficulty level 4. - In the fourth round, you complete 2 tasks of difficulty level 4. It can be shown that all the tasks cannot be completed in fewer than 4 rounds, so the answer is 4. Example 2: 123Input: tasks = [2,3,3]Output: -1Explanation: There is only 1 task of difficulty level 2, but in each round, you can only complete either 2 or 3 tasks of the same difficulty level. Hence, you cannot complete all the tasks, and the answer is -1. 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int getRounds(int value) &#123; int round=0; //if value is 1, then return -1 if(value==1)&#123; return -1; &#125; //if value is odd, then it consists of value/3 number of 3&#x27;s + one 2&#x27;s. //if value is even, it consists of even number of 3 + y number of 2&#x27;s. //[5,5,5,5] takes as many as 3&#x27;s, but [5,5,5][5] is not valid //we can split one 3&#x27;s, and it becomes [5,5] [5,5] return ceil(value/3.0); &#125; int minimumRounds(vector&lt;int&gt;&amp; tasks) &#123; //traverse the tasks, and cal num and its occurrance times //iterate dict, for each level,we need 3x+2y rounds. map&lt;int,int&gt; dict; for(auto task:tasks)&#123; dict[task]++; &#125; int res=0; for(auto it=dict.begin();it!=dict.end();it++)&#123; int curr=getRounds(it-&gt;second); if(curr==-1)&#123; return -1; &#125;else &#123; res+=curr; &#125; &#125; return res; &#125;&#125;; Correctness We should take as many 3’s as possible. If at any step, we takes Time complexity Say tasks has n elements. We put every element of tasks into dict and each insertion takes O(1) expected time. It will take O(n) expected time. We iterate every pair of dict, which will take O(n) time. Overall, the time complexity is O(n) time.","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"greedy","slug":"greedy","permalink":"https://illuca.github.io/tags/greedy/"}]},{"title":"COMP9319 week1 notes","slug":"COMP9319","date":"2023-06-03T08:49:23.000Z","updated":"2024-01-09T04:46:06.579Z","comments":true,"path":"2023/06/03/COMP9319/","link":"","permalink":"https://illuca.github.io/2023/06/03/COMP9319/","excerpt":"","text":"The difference betweeen online and physical is that you can talk with your peers after lecture. Raymond Wong also don’t like the course name. The course misses a lecturer and he becomes the one.compression - badsearch - ok compression and search means after making the data small, you can still search. the teacher of 6714 also resign and Raymond Wong becomes the lecturer. Even though you may did really bad in other cse courses, but if you are interested in it, you have the potential to learn it well. CompressionThere are two types of compression, one is lossless and another is lossy.Lossy does not mean bad, in some time, we like information loss, such as a photo blur the backgroudn.But in this course, we consider all info is valuable and focus on lossless compression. What is compression?Firstly, we code the data into a special format, which reduce the total number of bits needed to represent the data. Input data -&gt; Encode -&gt; Store in networks -&gt; Decode -&gt; Ouput dataAfter then, we encode it and get the data back. compression ratio is uncompressed size divide compressed size space savings = 1 - 1/compression ratio Example:There is a file with 30bits, which is also the uncompressed size.After compression, it becomes 10bits, which is also the compressed size.Then the compression ratio is 30/10=3:1Space savings is 1-1/3=2/3 first assignmentraaabbccccdabbbbeee$ encoder part of teacher’s solution is 150 lines and the decoder part is 160 lines. $ represents the end of file, you cannot see it in a file. Here, teacher likes $ and he uses $ to mark the end. So it is r1a3b2c4d1a4e3 But it is still not enough, because the original only has one r which takes up 1bit and after compression, the result is r1 taking up 2 bits.It is not compression but expanding. And 2 is also funny, rr becomes r2. You save no space but only make the text unreadable. The rule is that you don’t change things unless you do some stuff. So you do nothing unless there are 3 duplicate characters. But here is another problem. What if the orignal text is rrccr2?It can’t be r2c2r2. You have to make a rule. The start of duplicate symbol and end of it. Solution:Every character is stored in bytes.If the first bit is 0, then the remaining bits represents a character. Otherwise, the remaining bits is the length of previous character. So the text becomes ByteByteByteByteByte. Here is another problem, we have only 7bits to represent the length. So the value of length ranges from 0~127. Then what if the length is 100000000000000000? We can use two or more bytes to represent length.But why not just say 100 billion instead? Scheme2:AAA -&gt; A=3Because A and AA won’t be changed.Then if the length is 130, you are safe. Because 130-&gt;127 Sometimes, If you consider further improve, you go backward because of the complexity will influence the efficiency of the algorithm. problem: runs are usally smallBecause in a word, the duplicate character seldom appears. There is few word that have 3 duplicate characters in it. a glimpse of BWT+RLEit will be introduced in week3.It may only cost you 5 minutes to implement the BWT. But it will cost you a week to know why it works. HTTP compressionWhen the browser request a page, the server compresses the html page using gzip and send the compressed data to the browser.HTTP/1.1 200 OKContent-Type: text/html; charset=UTF-8Content-Encoding: gzip Then the browser using gzip to decode it, get the content and render the page. technologyTechnology has a very short lifetime, you either make the money or you just get away. If you work in Amazon, you will use compression techniques because there are messaging queues over there. If you can make the messges 10 times smaller then the queue can hold 10 times more messages. If you’re the application programmer, you never use it in your career. But if you’re a platform programmer, you do care bout it. StorwizeThe big companies make efforts to develop green energy not because they love the earth. But the electricity is expensive. For labor cost, you can fire them but for electricity, you have to mantain the equipment every month. The clients’ data is stored in those equipments. Less to store, less power used. But if you ask a student not studying 9319, he probably will say that who cares about compression? I can double my portable hard drives. Server -&gt; switches -&gt; IBM real-time compression equipment -&gt; storage For a hard drive, it is considered as good if it can fill every 50000 during test.But for google who must own 50000 hard drives, every second the hard drive may fail even they are brand new.And this is why you need big data to store it. Anti-virusThere is a company called cement tech.It stores anti-virus defnition in their amazon cloud.Every time the user downloads from the server, the server will check if the content has virus. So it has to be compressed otherwise the bandwith is huge, costing too much money. You may think why not they build their own cloud? Because it will be more expensive. You just pay for the short-time use for a storage service. So this is why when you download a software or update operating system, after downloading successfully, you have to wait for a long time. Because they decompress their softwares small to save money and expanding the data from decompression takes a long time. SD cardNow the mobile phone has 256g, then you need to search the information up to 256g. Then computation cost is huge. MicrosoftSTAC is a company to invent the compression. If you were born 30 years ago, you could found that company easily.Their product is less than 5000 lines, including interfaces and pages.The Microsoft dispatched technical staffs to check if the company really had something. And they were shocked because the product only had 5000 lines. So the Microsoft don’t pay for it but copy it after they came back.Although the staff in STAC are just undergraduate, but they found a good lawyer and finally won the case. gzipSometimes, you add extra info during compression. After first run of gzip, the file gets smaller.But after we changed the compressed file and change its name, we use gzip to compress it again. The file gets bigger. It is because if it cannot make it smaller, so it add overhead only. similarity measureIf things are more repetitive or redundant, you will compress more.If we compress two images together getting less compression ratio than compressing them seperately, it means there are lots of overlap between them, just like the duplicate character. Some people came out these ideas 20 years ago. They built a company but failed because they couldn’t make a theory into a good product. NOTEChange your perspective for information, which is vital for this course.You can go to ~cs9319/wk1 on cse.There are two txt, eg1.txt and eg2.txt, both with the same size 80B.eg1.txt has more repetitive characters then eg2.txt.So the previous file’s compressed size is smaller. sunny day and rainy dayWe can use bit 1 to represent rainy day and 0 for sunny day.This is what eg1.bin does and you can use xxd -b eg1.bin to look at it. you can make it more efficient using running and codingRunning and coding is the only algorithm you have ever learnt.If bit 0 represents sunny day, we use the first bit to represent if it is sunny or rainy.So 00000000 00000111 can be marked as 0[13] 0[3]. even even even more efficient by losing infoYou can just say S80. Because in normal case it is sunny. You just need to record the main info. sunny day, cloudy day and rainy daySunny day is marked as 00.Rainy day is marked as 01.Cloudy day is marked as 10. probabilitymore sunny days than rainy and cloudyThen we should use less bits to represent sunny and more bit to represent rainy. So they can be marked as:S: 0R: 10C: 11 ASCII CodeSince there is more A than Z in an English book. Why they are encoded with the same bit length?A: 65Z: 90 UTF-8It uses between 1 to 4 byte.If you use xxd to see the file with Chinese characters. It will use less bits to represent common Chinese characters. But i test it, all characters are 6*4=24bit in utf-8. use bits to mark the end of fileIf you don’t use EOF, then the last byte may be 00000000. But this byte does mean 8 sunny days, it does not represent anything. So there is the solution:S: 0R: 10C: 110EOF: 111 problem of RLERLE stands for run-length encoding.Most documents don’t have many runs. BWTIf you use BWT to compress a file. The file is smaller.And then you use gzip to compress it again. The file gets bigger, which means the gzip also uses BWT. efficient searchBWT cannot only do compression but also can do search after BWT compression.And its search only costs constant time, which means the search is independent of file size.If after BWT, the file is 1MB the search costs 1 sec.Then if another file is 1GB after BWT, the search still costs only 1 sec. what is COMP9319? how different compression algorithms work We only learn classic algorithms because all new algorithms are derived from those. After you learn the classic ones, you can learn others new by yourself easily. We also cares about small device not only care about big companies devices. Because the final end is the user, is our computer. If you can make your program quicker in your device, then you can make millons of computers running faster. Algorithm is the money. If you figure out an algorithm which can make file smaller, then what you are doing is saving money. how to search without index? If the search is slow, you can use database to create index using btree or hash table. You just only to type one command to do it. But what is the cost? You have to maintain the index when you update data you need to update the index as well. Index is not cheap. It works well only when you are rich and can buy many servers. Don’t build index unless it is necessary because you need to load more from the disk to memory and CPU need to compute more to decode the index. So how to use minimum index and do the maximum efficiency for search? That’s what the course will discuss. course infoFriday 2 hours live 3 hours pre-recorded Raymond WongAreas: database, information retrieval, big data SYSTEM TEXT mining He is a system person but not in theory. live lecturesHe will interact with students except week1 because in week1 students have no idea about what to ask.Possible questions: How do you implement this? exercisesExams are similar to exercises. consulationsYou can see the schedule in webcms. Online: Tuesday 13:30 and Wednesday 20:00 for week2-5, 7-11 moodle collaborate blackboardIn person: Friday 14:00 for week3-5, 7-11 K-E12-114-BUS114 two assignmentsIf you think the assignment is not difficult enough, you can ask for an advanced project with 2 sub assignments.","categories":[],"tags":[{"name":"UNSW","slug":"UNSW","permalink":"https://illuca.github.io/tags/UNSW/"},{"name":"notes","slug":"notes","permalink":"https://illuca.github.io/tags/notes/"}]},{"title":"ANZAC CONTEST 4","slug":"ANZAC-CONTEST-4","date":"2023-05-28T11:51:29.000Z","updated":"2023-11-02T09:32:45.979Z","comments":true,"path":"2023/05/28/ANZAC-CONTEST-4/","link":"","permalink":"https://illuca.github.io/2023/05/28/ANZAC-CONTEST-4/","excerpt":"","text":"ANote: You cannot focus on who wins the game. You should just follow the description in the problem “X is the score of the player who serves”. So 1-0 is Bob serve. Then Bob’s score is 1. 1234Exp1:20-01-0 And Exp2 is valid. 12345Exp2:30-01-101-11 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); int currRound = 0; int prevAlice = 0, prevBob = 0; for (int i = 1; i &lt;= n; i++) &#123; int alice, bob; scanf(&quot;%d-%d&quot;, &amp;alice, &amp;bob); currRound = alice + bob; if (currRound % 4 == 1 || currRound % 4 == 2) &#123; swap(alice, bob); &#125; //their score must in [0,11] if (!(alice &gt;= 0 &amp;&amp; alice &lt;= 11 &amp;&amp; bob &gt;= 0 &amp;&amp; bob &lt;= 11)) &#123; cout &lt;&lt; &quot;error &quot; &lt;&lt; i; exit(0); &#125; //during the game, alice must &gt;= prev alice and bob must &gt;= prev bob if (!(alice &gt;= prevAlice &amp;&amp; bob &gt;= prevBob)) &#123; cout &lt;&lt; &quot;error &quot; &lt;&lt; i; exit(0); &#125; //when game is over, their scores cannot be changed if ((prevBob == 11 || prevAlice == 11) &amp;&amp; !(bob == prevBob &amp;&amp; alice == prevAlice) // special condition check || alice == 11 &amp;&amp; bob == 11) &#123; cout &lt;&lt; &quot;error &quot; &lt;&lt; i; exit(0); &#125; //set prev as curr prevBob = bob; prevAlice = alice; &#125; cout &lt;&lt; &quot;ok&quot;; return 0;&#125;","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://illuca.github.io/tags/algorithm/"}]},{"title":"1002 A+B for Polynomials","slug":"1002-A-B-for-Polynomials","date":"2023-05-26T15:47:19.000Z","updated":"2023-11-02T09:25:24.517Z","comments":true,"path":"2023/05/27/1002-A-B-for-Polynomials/","link":"","permalink":"https://illuca.github.io/2023/05/27/1002-A-B-for-Polynomials/","excerpt":"","text":"https://pintia.cn/problem-sets/994805342720868352/exam/problems/994805526272000000 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;map&gt;using namespace std;int main() &#123; int k1; cin &gt;&gt; k1; map&lt;int, float, greater&lt;&gt;&gt; m; for (int i = 0; i &lt; k1; i++) &#123; int key; float value; cin &gt;&gt; key; cin &gt;&gt; value; m[key] += value; if (m[key]==0) &#123; m.erase(key); &#125; &#125; int k2; cin &gt;&gt; k2; for (int i = 0; i &lt; k2; i++) &#123; int key; float value; cin &gt;&gt; key; cin &gt;&gt; value; m[key] += value; if (m[key]==0) &#123; m.erase(key); &#125; &#125; cout &lt;&lt; m.size(); for (auto &amp;pair: m) &#123; if (pair.second != 0) &#123; printf(&quot; %d %.1f&quot;, pair.first, pair.second); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://illuca.github.io/tags/PAT/"}]},{"title":"1001 A+B Format","slug":"1001-A-B-Format","date":"2023-05-26T13:17:20.000Z","updated":"2023-05-26T11:46:11.501Z","comments":true,"path":"2023/05/26/1001-A-B-Format/","link":"","permalink":"https://illuca.github.io/2023/05/26/1001-A-B-Format/","excerpt":"","text":"Calculate a+b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits). Input Specification:Each input file contains one test case. Each case contains a pair of integers a and b where −10^6≤a,b≤10^6. The numbers are separated by a space. Output Specification:For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format. Sample Input:1-1000000 9 Sample Output:1-999,991 1234567891011Code Size Limit16 KBTime Limit400 msMemory Limit64 MB Because -10^6&lt;=a,b&lt;=10^6 and the max number of signed integer in c++ is 2^31-1=2147483647 &gt; 10^6, so we can just use int. 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main() &#123; int a, b; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); int summ = a + b;// convert abs(summ) into a string and traverse the string string ans = &quot;&quot;;//insert , if current pointer is 3 and is not the last ch then ans=&quot;,&quot;+[curr] string s = to_string(abs(summ)); string flag = &quot;&quot;; if (summ &lt; 0) &#123; flag = &quot;-&quot;; &#125; //i=1, len-1, [len-1] is the right=1 //i=2, len-2, [len-2] is the right=2, two digits int i = 1, len = s.size(); for (;;) &#123; int index = len - i; ans = s[index] + ans; if (i % 3 == 0 &amp;&amp; len - i != 0) &#123; ans = &quot;,&quot; + ans; &#125; i++; if (i &gt; len) &#123; //when i=len, [0] break; &#125; &#125; ans = flag + ans; cout &lt;&lt; ans; return 0;&#125; But actually, to_string give me the sign of a+b, so i don’t need to check if a+b is less than 0. In addition, it use O(n) space, which can be optimised. 12345678910111213141516171819202122232425262728293031323334353637#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int main() &#123; int a, b; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); int sum = a + b; string s = to_string(sum); //from left to right //i=0, from right it is len th //i=1, from right it is len-1 th //i=len, 0th //if [i] is &#x27;-&#x27;, print it //else: //if len-i is multiple of 4 and len-i is not 0 then print [i] and , int len = s.size(); for (int i = 0; i &lt; len; i++) &#123; if (s[i] == &#x27;-&#x27;) &#123; cout &lt;&lt; s[i]; &#125; else &#123; if ((len - i - 1) % 3 == 0 &amp;&amp; i != len - 1) &#123; cout &lt;&lt; s[i] &lt;&lt; &quot;,&quot;; &#125; else &#123; cout &lt;&lt; s[i]; &#125; &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://illuca.github.io/tags/PAT/"}]},{"title":"Segment Tree","slug":"Segment-Tree","date":"2023-05-26T05:26:44.000Z","updated":"2024-01-09T03:52:26.455Z","comments":true,"path":"2023/05/26/Segment-Tree/","link":"","permalink":"https://illuca.github.io/2023/05/26/Segment-Tree/","excerpt":"","text":"Range LCM Queries123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include&lt;vector&gt;using namespace std;//There is an array arr. It has N integers.//There is another array query. Each element of query is a range for arr, like [L,R]//[L,R] has many integers, my job is to find the least common multiple for them.//Example: [3,6]=arr[3],arr[4],arr[5],arr[6]//LCM(a,b)=a*b/GCD(a,b)int gcd(int x, int y) &#123; if (x==0)&#123; return y; &#125; return gcd(y % x, x);&#125;//LCM accepts two parameter: vector&lt;int&gt;, vector&lt;int&gt;//return an integervoid LCM(vector&lt;int&gt; arr, vector&lt;vector&lt;int&gt;&gt; query)&#123; //let us firstly consider one query, query[0] //LCM of [i] and [i+1] is [i]*[i+1]/gcd([i],[i+1] //traverse from query[0][0],query[0][1]] for(auto v:query)&#123; int left=v[0], right=v[1]; int lcm=1; for(int i=left; i&lt;=right;i++)&#123; lcm = lcm * arr[i] / gcd(lcm, arr[i]); &#125; cout &lt;&lt; lcm &lt;&lt; endl; &#125;&#125;int main() &#123; vector&lt;int&gt; arr = &#123;5, 7, 5, 2, 10, 12, 11, 17, 14, 1, 44&#125;; vector&lt;vector&lt;int&gt;&gt; query = &#123;&#123;2, 5&#125;, &#123;5, 10&#125;, &#123;0, 10&#125;&#125;; LCM(arr, query); return 0;&#125; Using segment tree can make it more efficient. We use O(nlogn) time to convert the array into a tree. Then for each query, it only costs O(logn) time. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; tree;vector&lt;int&gt; arr;int gcd(int x, int y) &#123; if (x == 0) &#123; return y; &#125; return gcd(y % x, x);&#125;int lcm(int x, int y) &#123; return x / gcd(x, y) * y;&#125;//cut up util mouth of [lquery, rquery] can swallow [left, right]int query(int root, int larr, int rarr, int lquery, int rquery) &#123; // if two ranges have no common part if (lquery &gt; rarr || rquery &lt; larr) &#123; // we must deal with such condition and lcm(1,x)=x return 1; &#125; if (lquery &lt;= larr &amp;&amp; rarr &lt;= rquery) &#123; return tree[root]; &#125; //lcm = lcm of left part and right part int mid = larr + ((rarr - larr) &gt;&gt; 1); int l = query(2 * ]]]] ]]] root, larr, mid, lquery, rquery); int r = query(2 * root + 1, mid + 1, rarr, lquery, rquery); return lcm(l, r);&#125;void build(int root, int larr, int rarr) &#123; //if it is a leaf, then store the element of arr if (larr == rarr) &#123; //leaf only has one element tree[root] = arr[larr]; return; &#125; int mid = larr + ((rarr - larr) &gt;&gt; 1); //turn left part of arr into a tree build(root * 2, larr, mid); //turn right part of arr into a tree build(root * 2 + 1, mid + 1, rarr); //root store the lcm of left and right node tree[root] = lcm(tree[root * 2], tree[root * 2 + 1]);&#125;int main() &#123; arr = &#123;5, 7, 5, 2, 10, 12, 11, 17, 14, 1, 44&#125;; vector&lt;vector&lt;int&gt;&gt; queries = &#123;&#123;2, 5&#125;, &#123;5, 10&#125;, &#123;0, 10&#125;&#125;; tree.resize(1000, 0); //init a tree array and convert arr into a tree //root index is 1, left is 2*root, right is 2*root+1 build(1, 0, arr.size() - 1); for (auto q: queries) &#123; //query start from root //lquery is q[0], rquery is q[1] cout &lt;&lt; query(1, 0, arr.size() - 1, q[0], q[1]) &lt;&lt; endl; &#125; return 0;&#125;","categories":[],"tags":[{"name":"tree","slug":"tree","permalink":"https://illuca.github.io/tags/tree/"},{"name":"LCM","slug":"LCM","permalink":"https://illuca.github.io/tags/LCM/"},{"name":"segment tree","slug":"segment-tree","permalink":"https://illuca.github.io/tags/segment-tree/"}]},{"title":"236. Lowest Common Ancestor of a Binary Tree","slug":"236-Lowest-Common-Ancestor-of-a-Binary-Tree","date":"2023-05-23T05:38:18.000Z","updated":"2024-01-09T04:17:53.261Z","comments":true,"path":"2023/05/23/236-Lowest-Common-Ancestor-of-a-Binary-Tree/","link":"","permalink":"https://illuca.github.io/2023/05/23/236-Lowest-Common-Ancestor-of-a-Binary-Tree/","excerpt":"","text":"Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Example 1: 123Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1Output: 3Explanation: The LCA of nodes 5 and 1 is 3. Example 2: 123Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4Output: 5Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. Example 3: 12Input: root = [1,2], p = 1, q = 2Output: 1 Constraints: The number of nodes in the tree is in the range [2, 105]. -109 &lt;= Node.val &lt;= 109 All Node.val are unique. p != q p and q will exist in the tree. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; // Now you have a binary tree and root is the root of the tree. // p and q are the two nodes in this tree. // p and q have the common descendant. They have many descendants. But i need to find the lowest one. // I should keep finding their parent util their parent in the same level. // Every time their parents are int the same level, check if they are the same node. // traverse the whole tree and make a parent map=&#123;&#123;node: parent&#125;&#125; and depth[node]=depth. // depth of root node is 1, pop and push two new nodes in stack and their depth are previous poped node depth+1 if(root==NULL)&#123; return root; &#125; stack&lt;TreeNode*&gt; s; s.push(root); map&lt;int,int&gt; depth; map&lt;TreeNode*,TreeNode*&gt; parent; set&lt;int&gt; visited; //init parent, every node&#x27;s parent is itself. parent[root]=root; depth[root-&gt;val]=1; while(!s.empty())&#123; TreeNode* curr=s.top(); s.pop(); visited.insert(curr-&gt;val); int d=depth[curr-&gt;val]; if(curr-&gt;right!=NULL)&#123; s.push(curr-&gt;right); depth[curr-&gt;right-&gt;val]=d+1; parent[curr-&gt;right]=curr; &#125; if(curr-&gt;left!=NULL)&#123; s.push(curr-&gt;left); depth[curr-&gt;left-&gt;val]=d+1; parent[curr-&gt;left]=curr; &#125; //if both p and q are visited, then break in advance if(visited.count(p-&gt;val) &amp;&amp; visited.count(q-&gt;val)) &#123; break; &#125; &#125; TreeNode* pParent=p, *qParent=q; //every node has its parent except for the root while(parent[pParent]-&gt;val!=pParent-&gt;val || parent[qParent]-&gt;val!=pParent-&gt;val)&#123; if(depth[pParent-&gt;val]==depth[qParent-&gt;val]) &#123; if(pParent-&gt;val==qParent-&gt;val) &#123; return pParent; &#125;else&#123; pParent=parent[pParent]; qParent=parent[qParent]; &#125; &#125; //if pParent depth &lt; qParent depth, then qParent should be higher else if(depth[pParent-&gt;val]&lt;depth[qParent-&gt;val])&#123; qParent=parent[qParent]; &#125; else &#123; pParent=parent[pParent]; &#125; &#125; return root; &#125;&#125;; Use recursion can be more efficient because using map in each loop. 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; //discuss conditions from leaf to root // if curr is child of leaf, then return null // if curr is a leaf: // if curr finds p or q, then return curr // if curr is parent of left and right: // if curr finds p or q, then return curr // else: // if curr.left finds one and curr.right also finds one, then return curr. // if curr.left finds one and curr.right does not find, then another one may be child of that one or does not exist in curr tree. No matter which condition, return current tree. // if right.left finds one and curr.left does not find, the same as above. // if no one found, then return NULL; if(!root)&#123; return NULL; &#125; if(root-&gt;val==p-&gt;val || root-&gt;val==q-&gt;val)&#123; return root; &#125; else &#123; TreeNode* left=lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right=lowestCommonAncestor(root-&gt;right, p, q); if(left&amp;&amp;!right)&#123; return left; &#125;else if(!left&amp;&amp;right)&#123; return right; &#125;else if (left&amp;&amp;right)&#123; return root; &#125; else &#123; return NULL; &#125; &#125; &#125;&#125;; Note: All return value will point to left and right because left and right is the entrance. This method is also easy to understand. We store the path of root to n1 and root to n2.if path1=[root, n1] and path2=[root, n2], then first mismatch is n1!=n2. The previous node is their LCA. 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: bool findPath(TreeNode* root, vector&lt;TreeNode*&gt; &amp;path, int target) &#123; //if curr is child of leaf, then return null //if curr is root: //insert current val //check if current val equals target then return true //else: //if left child finds, then return true //if right finds, then return true //if not found, then target does not exist in curr tree, then we should go back and clear our footprint if(!root) return root; path.push_back(root); if(root-&gt;val==target)&#123; return true; &#125; bool left=findPath(root-&gt;left, path, target); bool right=findPath(root-&gt;right, path, target); if(left || right)&#123; return true; &#125;else&#123; path.pop_back(); return false; &#125; &#125; TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; vector&lt;TreeNode*&gt;path1; vector&lt;TreeNode*&gt;path2; // p and q all exist in the tree, so we don&#x27;t need to check findPath(root,path1,p-&gt;val); findPath(root,path2,q-&gt;val); int i; for(i=0; i&lt;path1.size() &amp;&amp; i&lt;path2.size();i++)&#123; //if equal, then continue, else break if(path1[i]-&gt;val!=path2[i]-&gt;val) &#123; break; &#125; &#125; return path1[i-1]; &#125;&#125;; Tarjan’s off -line LCA is not efficient in this problem, but i just want to practice. You can find more details on https://www.geeksforgeeks.org/tarjans-off-line-lowest-common-ancestors-algorithm/. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586class Solution &#123; unordered_map&lt;TreeNode*, TreeNode*&gt; parent; unordered_map&lt;TreeNode*, TreeNode*&gt; child; unordered_map&lt;TreeNode*, TreeNode*&gt; sibling; unordered_map&lt;TreeNode*, bool&gt; visited; TreeNode* pp, *qq; TreeNode* ans;public: //init parent, child, sibling void LCA(TreeNode* root)&#123; if(!root) return; // init parent parent[root]=root; //if left and right are not null if(root-&gt;left)&#123; child[root]=root-&gt;left; &#125; if(!root-&gt;left&amp;&amp;root-&gt;right)&#123; child[root]=root-&gt;right; &#125; if(root-&gt;left&amp;&amp;root-&gt;right)&#123; sibling[root-&gt;left]=root-&gt;right; &#125; LCA(root-&gt;left); LCA(root-&gt;right); &#125; // x be the parent void unionSet(TreeNode* x, TreeNode* y) &#123; //find root of x TreeNode* xroot=findSet(x); //find root of y TreeNode* yroot=findSet(y); parent[yroot]=xroot; &#125; TreeNode* findSet(TreeNode* x) &#123; //keep find the parent util itself while(parent[x]!=x)&#123; x=parent[x]; &#125; return x; &#125; void walk(TreeNode* root) &#123; if(!root) return; //go to leftest and set its parent and ancestor TreeNode* node=child[root]; while(node) &#123; //walk left walk(node); //union root and node unionSet(root,node); //walk right node=sibling[node]; &#125; // if curr equals one of targets, then set visited // if another target B has been visited, then B&#x27;s ancestor is the LCA // ans=findSet(B); // if another target A has been visited, then A&#x27;s ancestor is the LCA // ans=findSet(A) if(ans) &#123; return; &#125; if(root-&gt;val==pp-&gt;val || root-&gt;val==qq-&gt;val) &#123; visited[root]=true; if(root-&gt;val==pp-&gt;val &amp;&amp; visited[qq])&#123; // find another qq ans=findSet(qq); return; &#125; if(root-&gt;val==qq-&gt;val &amp;&amp; visited[pp])&#123; ans=findSet(pp); return; &#125; &#125; &#125; TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; //subset[root].child=root-&gt;left //init subset LCA(root); pp=p; qq=q; walk(root); return ans; &#125;&#125;; And then we can use path compression to make it quicker. But i don’t know why leetcode tells me the program gets slower and use more memory. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123; unordered_map&lt;TreeNode*, TreeNode*&gt; parent; unordered_map&lt;TreeNode*, TreeNode*&gt; child; unordered_map&lt;TreeNode*, TreeNode*&gt; sibling; unordered_map&lt;TreeNode*, bool&gt; visited; TreeNode* pp, *qq; TreeNode* ans;public: //init parent, child, sibling void LCA(TreeNode* root)&#123; if(!root) return; // init parent parent[root]=root; //if left and right are not null if(root-&gt;left)&#123; child[root]=root-&gt;left; &#125; if(!root-&gt;left&amp;&amp;root-&gt;right)&#123; child[root]=root-&gt;right; &#125; if(root-&gt;left&amp;&amp;root-&gt;right)&#123; sibling[root-&gt;left]=root-&gt;right; &#125; LCA(root-&gt;left); LCA(root-&gt;right); &#125; // x be the parent void unionSet(TreeNode* x, TreeNode* y) &#123; //find root of x TreeNode* xroot=findSet(x); //find root of y TreeNode* yroot=findSet(y); parent[yroot]=xroot; &#125; TreeNode* findSet(TreeNode* x) &#123; //keep find the parent util itself while(parent[x]!=x)&#123; x=parent[x]; &#125; return x; &#125; void walk(TreeNode* root) &#123; if(!root) return; //go to leftest and set its parent and ancestor TreeNode* node=child[root]; while(node) &#123; //walk left walk(node); //union root and node unionSet(root,node); //walk right node=sibling[node]; &#125; // if curr equals one of targets, then set visited // if another target B has been visited, then B&#x27;s ancestor is the LCA // ans=findSet(B); // if another target A has been visited, then A&#x27;s ancestor is the LCA // ans=findSet(A) if(ans) &#123; return; &#125; if(root-&gt;val==pp-&gt;val || root-&gt;val==qq-&gt;val) &#123; visited[root]=true; if(root-&gt;val==pp-&gt;val &amp;&amp; visited[qq])&#123; // find another qq ans=findSet(qq); return; &#125; if(root-&gt;val==qq-&gt;val &amp;&amp; visited[pp])&#123; ans=findSet(pp); return; &#125; &#125; &#125; TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; //subset[root].child=root-&gt;left //init subset LCA(root); pp=p; qq=q; walk(root); return ans; &#125;&#125;; I think it is because i use multiple map, i should merge them into a subset. I think it works as image shows. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104typedef struct &#123; TreeNode* ancestor; TreeNode* parent; TreeNode* child; TreeNode* sibling; bool visited; int rank;&#125; subset;class Solution &#123; unordered_map&lt;TreeNode*, subset&gt; subset; TreeNode* pp, *qq; TreeNode* ans;public: //init parent, child, sibling void LCA(TreeNode* root)&#123; if(!root) return; // init parent subset[root].ancestor=root; subset[root].parent=root; subset[root].ancestor=root; subset[root].rank=0; //if left and right are not null if(root-&gt;left)&#123; subset[root].child=root-&gt;left; &#125; if(!root-&gt;left&amp;&amp;root-&gt;right)&#123; subset[root].child=root-&gt;right; &#125; if(root-&gt;left&amp;&amp;root-&gt;right)&#123; subset[root-&gt;left].sibling=root-&gt;right; &#125; LCA(root-&gt;left); LCA(root-&gt;right); &#125; // x be the parent void unionSet(TreeNode* x, TreeNode* y) &#123; //find root of x TreeNode* xroot=findSet(x); //find root of y TreeNode* yroot=findSet(y); //if rank equal then x be parent if(subset[xroot].rank==subset[yroot].rank)&#123; subset[yroot].parent=xroot; subset[xroot].rank++; &#125;else if(subset[xroot].rank&lt;subset[yroot].rank)&#123; subset[xroot].parent=yroot; &#125;else&#123; subset[yroot].parent=xroot; &#125; //else if node with higher rank be the parent &#125; TreeNode* findSet(TreeNode* x) &#123; //keep find the parent util itself while(subset[x].parent!=x)&#123; x=subset[x].parent; &#125; return x; &#125; void walk(TreeNode* root) &#123; if(!root) return; //go to leftest and set its parent and ancestor TreeNode* node=subset[root].child; while(node) &#123; //walk left walk(node); //union root and node unionSet(root,node); //walk right subset[findSet(node)].ancestor=root; node=subset[node].sibling; &#125; // if curr equals one of targets, then set visited // if another target B has been visited, then B&#x27;s ancestor is the LCA // ans=findSet(B); // if another target A has been visited, then A&#x27;s ancestor is the LCA // ans=findSet(A) if(ans) &#123; return; &#125; if(root-&gt;val==pp-&gt;val || root-&gt;val==qq-&gt;val) &#123; subset[root].visited=true; if(root-&gt;val==pp-&gt;val &amp;&amp; subset[qq].visited)&#123; // find another qq ans=subset[findSet(qq)].ancestor; return; &#125; if(root-&gt;val==qq-&gt;val &amp;&amp; subset[pp].visited)&#123; ans=subset[findSet(pp)].ancestor; return; &#125; &#125; &#125; TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; //subset[root].child=root-&gt;left //init subset LCA(root); pp=p; qq=q; walk(root); return ans; &#125;&#125;; We can also use mutation of tarjan’s LCA. The core is the visited mark. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778typedef struct &#123; TreeNode* ancestor; TreeNode* parent; bool visited; int rank;&#125; subset;class Solution &#123; unordered_map&lt;TreeNode*, subset&gt; subset; TreeNode* pp, *qq; TreeNode* ans;public: // x be the parent void unionSet(TreeNode* x, TreeNode* y) &#123; //find root of x TreeNode* xroot=findSet(x); //find root of y TreeNode* yroot=findSet(y); //if rank equal then x be parent if(subset[xroot].rank==subset[yroot].rank)&#123; subset[yroot].parent=xroot; subset[xroot].rank++; &#125;else if(subset[xroot].rank&lt;subset[yroot].rank)&#123; subset[xroot].parent=yroot; &#125;else&#123; subset[yroot].parent=xroot; &#125; //else if node with higher rank be the parent &#125; TreeNode* findSet(TreeNode* x) &#123; //keep find the parent util itself while(subset[x].parent!=x)&#123; x=subset[x].parent; &#125; return x; &#125; TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; //init subset[root] //go to left child //union current and left //go to right child //union current and right TreeNode* res=NULL; if(!root) return NULL; subset[root].parent=root; subset[root].ancestor=root; if(root-&gt;left) &#123; res=lowestCommonAncestor(root-&gt;left, p, q); unionSet(root, root-&gt;left); subset[findSet(root-&gt;left)].ancestor=root; if(res)&#123; return res; &#125; &#125; if(root-&gt;right)&#123; res=lowestCommonAncestor(root-&gt;right, p, q); unionSet(root, root-&gt;right); subset[findSet(root-&gt;right)].ancestor=root; if(res)&#123; return res; &#125; &#125; //if curr find any of targets //if curr finds target A and B is visted, then B&#x27;s ancestor is LCA //if curr finds target B and A is visited, then A&#x27;s ancestor is LCA if(root-&gt;val==p-&gt;val || root-&gt;val==q-&gt;val) &#123; subset[root].visited=true; if(root-&gt;val==p-&gt;val &amp;&amp; subset[root].visited) &#123; return subset[findSet(q)].ancestor; &#125; if(root-&gt;val==q-&gt;val &amp;&amp; subset[root].visited) &#123; return subset[findSet(p)].ancestor; &#125; &#125; return res; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"tree","slug":"tree","permalink":"https://illuca.github.io/tags/tree/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"LCA","slug":"LCA","permalink":"https://illuca.github.io/tags/LCA/"},{"name":"recursion","slug":"recursion","permalink":"https://illuca.github.io/tags/recursion/"},{"name":"tarjan","slug":"tarjan","permalink":"https://illuca.github.io/tags/tarjan/"},{"name":"union find","slug":"union-find","permalink":"https://illuca.github.io/tags/union-find/"}]},{"title":"69. Sqrt(x)","slug":"69-Sqrt-x","date":"2023-05-22T06:46:04.000Z","updated":"2023-11-02T09:24:09.673Z","comments":true,"path":"2023/05/22/69-Sqrt-x/","link":"","permalink":"https://illuca.github.io/2023/05/22/69-Sqrt-x/","excerpt":"","text":"Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well. You must not use any built-in exponent function or operator. For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python. Example 1: 123Input: x = 4Output: 2Explanation: The square root of 4 is 2, so we return 2. Example 2: 123Input: x = 8Output: 2Explanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned. Constraints: 0 &lt;= x &lt;= $2^{31}$ - 1 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: int mySqrt(int x) &#123; //i have a non-negative integer. //non-negative means i can be 0 or greater than 0. //i need to find the square root of x and if x is not an integer, then round it down. // if x=2, then mid=0+2/2=1 // mid^2&lt;2, so check right part=[mid,x]=[1,2], left=mid=1, mid=1+2/2=1 // loop should meet: left+1&lt;=right // int left=0, right=x; // if x=3,then mid=0+x/2=1 // 1^2&lt;3, so check right part=[1,3], left=1, mid=2 // 2^2&gt;3, so check left part=[1,2], right=2, mid=1 // 1^2&lt;3, so check right part=[1,2] long left=0, right=x; for(;;)&#123; long mid=left+((right-left)&gt;&gt;1); long mul=mid*mid; if(mul==x) &#123; return mid; &#125;else if(mul&lt;x) &#123; //check right if(left+1==right)&#123; if(right*right==x) &#123; return right; &#125; else &#123; return left; &#125; &#125; left=mid; &#125;else &#123; //check left if(left+1==right) &#123; if(right*right==x) &#123; return right; &#125;else &#123; return left; &#125; &#125; right=mid; &#125; &#125; &#125;&#125;; If you don’t use long, you can use trick mid==x/mid. But be careful, 0 cannot be denominator. 1234567891011121314151617181920212223class Solution &#123;public: int mySqrt(int x) &#123; if(x==0)&#123; return 0; &#125; int left=1, right=x; for(;left&lt;=right;)&#123; int mid=left+(right-left)/2; if(mid==x/mid)&#123; return mid; &#125;else if(mid&gt;x/mid)&#123; //check left right=mid-1; &#125;else&#123; //check right left=mid+1; &#125; &#125; //if does not find, then left &gt; right, return smaller one return right; &#125;&#125;; About return value: Say we have only two elements: [1,2]. mid is 1, in the front. right=mid-1 cause exit and we want the round down. right &lt; left, so return right. Say we have only 1 elements: [1]. mid is 1, in the front. left=mid+1 cause exit and we want round down. right &lt; left, so return right. [2023-09-26 Tue 14:55] Notice that the candidate answer is always in “less branch”, thus we store the mid in that branch. 12345678910111213141516class Solution: def mySqrt(self, x: int) -&gt; int: low = 1 high = x ans = 0 while low &lt;= high: mid = (low + high) // 2 if mid * mid == x: return mid elif mid * mid &lt; x: low = mid + 1 ans = mid else: high = mid - 1 return ans","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"https://illuca.github.io/tags/easy/"},{"name":"binary-search","slug":"binary-search","permalink":"https://illuca.github.io/tags/binary-search/"}]},{"title":"278. First Bad Version","slug":"278-First-Bad-Version","date":"2023-05-22T05:40:13.000Z","updated":"2023-11-02T09:26:01.609Z","comments":true,"path":"2023/05/22/278-First-Bad-Version/","link":"","permalink":"https://illuca.github.io/2023/05/22/278-First-Bad-Version/","excerpt":"","text":"https://leetcode.com/problems/first-bad-version/description/ You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. Example 1: 1234567Input: n = 5, bad = 4Output: 4Explanation:call isBadVersion(3) -&gt; falsecall isBadVersion(5) -&gt; truecall isBadVersion(4) -&gt; trueThen 4 is the first bad version. Example 2: 12Input: n = 1, bad = 1Output: 1 Constraints: 1 &lt;= bad &lt;= n &lt;= 231 - 1 1234567891011121314151617181920212223242526272829303132333435363738// The API isBadVersion is defined for you.// bool isBadVersion(int version);class Solution &#123;public: int firstBadVersion(int n) &#123; //i am a manager and has a team developing a product. //the latest product fails. Because the new version is based on previous version. So i need to find the earliest version that fails. //i can use isBadVersion to check if it is bad. //i can&#x27;t use API for too many times. //our product versions is like: [1,2,3....n], is in ascending order //check if [i] is bad and [i-1] is good then return [i] //if [i-1] is bad also then check left part //check if [i] is good and [i+1] is bad then return [i+1] //if [i+1] is good also then check right part int low=0,high=n; for(int mid=low+((high-low)&gt;&gt;1);low&lt;=high;)&#123; if(isBadVersion(mid))&#123; if(mid-1&gt;=0&amp;&amp;!isBadVersion(mid-1))&#123; return mid; &#125;else&#123; //check left high=mid-1; mid=low+((high-low)&gt;&gt;1); &#125; &#125;else &#123; if(mid+1&lt;=n-1&amp;&amp;isBadVersion(mid+1))&#123; return mid+1; &#125;else&#123; //check right low=mid+1; mid=low+((high-low)&gt;&gt;1); &#125; &#125; &#125; return n; &#125;&#125;; It can be more clear. 123456789101112131415161718192021222324// The API isBadVersion is defined for you.// bool isBadVersion(int version);class Solution &#123;public: int firstBadVersion(int n) &#123; int left=1, right=n; for(;left&lt;=right;)&#123; int mid=left+((right-left)&gt;&gt;1); if(isBadVersion(mid))&#123; //check left. It may cause empty array. //[Bad1,Bad2]-&gt;[]. return left //[bad]-&gt;[]. return left right=mid-1; &#125;else&#123; //check right //[good,bad]-&gt;[bad] left=mid+1; &#125; &#125; // when break, all exit is to return left. return left; &#125;&#125;; Another way to think return value is to consider the break condition. When not found, right=mid-1 &lt; left. Of course we need the one in the back.","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"https://illuca.github.io/tags/easy/"},{"name":"binary-search","slug":"binary-search","permalink":"https://illuca.github.io/tags/binary-search/"}]},{"title":"744. Find Smallest Letter Greater Than Target","slug":"744-Find-Smallest-Letter-Greater-Than-Target","date":"2023-05-21T15:34:56.000Z","updated":"2023-11-02T09:25:32.589Z","comments":true,"path":"2023/05/22/744-Find-Smallest-Letter-Greater-Than-Target/","link":"","permalink":"https://illuca.github.io/2023/05/22/744-Find-Smallest-Letter-Greater-Than-Target/","excerpt":"","text":"https://leetcode.com/problems/find-smallest-letter-greater-than-target/description/ You are given an array of characters letters that is sorted in non-decreasing order, and a character target. There are at least two different characters in letters. Return the smallest character in letters that is lexicographically greater than target. If such a character does not exist, return the first character in letters. Example 1: 123Input: letters = [&quot;c&quot;,&quot;f&quot;,&quot;j&quot;], target = &quot;a&quot;Output: &quot;c&quot;Explanation: The smallest character that is lexicographically greater than &#x27;a&#x27; in letters is &#x27;c&#x27;. Example 2: 123Input: letters = [&quot;c&quot;,&quot;f&quot;,&quot;j&quot;], target = &quot;c&quot;Output: &quot;f&quot;Explanation: The smallest character that is lexicographically greater than &#x27;c&#x27; in letters is &#x27;f&#x27;. Example 3: 123Input: letters = [&quot;x&quot;,&quot;x&quot;,&quot;y&quot;,&quot;y&quot;], target = &quot;z&quot;Output: &quot;x&quot;Explanation: There are no characters in letters that is lexicographically greater than &#x27;z&#x27; so we return letters[0]. Constraints: 2 &lt;= letters.length &lt;= 104 letters[i] is a lowercase English letter. letters is sorted in non-decreasing order. letters contains at least two different characters. target is a lowercase English letter. 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: char nextGreatestLetter(vector&lt;char&gt;&amp; letters, char target) &#123; //idea //use binary search to find the char that greater than target. //if target is less than [i] then check right part. //if target equals [i] then check if [i+1] greater than target, then return [i+1]. but check i+1 overflow first. //if target greater than [i] then check if [i-1] equals target int N=letters.size(); int low=0, high=N-1; for(int mid=high&gt;&gt;1;low&lt;=high;)&#123; if(target==letters[mid])&#123; if(mid+1&lt;N&amp;&amp;target&lt;letters[mid+1]) &#123; return letters[mid+1]; &#125; // check right part low=mid+1; mid=low+((high-low)&gt;&gt;1); &#125; else if(target&lt;letters[mid]) &#123; //ensure [mid] is the first to be greater than target if(mid-1&gt;=0&amp;&amp;target&gt;=letters[mid-1])&#123; return letters[mid]; &#125; if(mid==0) &#123; return letters[0]; &#125; //check left high=mid-1; mid=low+((high-low)&gt;&gt;1); &#125; else &#123; // target&gt;letters[mid] //check right low=mid+1; mid=low+((high-low)&gt;&gt;1); &#125; &#125; return letters[0]; &#125;&#125;; Of course you can use upper_bound. 123456auto it = upper_bound(letters.begin(), letters.end(), target);if(it == letters.end()) &#123; return letters[0];&#125;else&#123; return *it;&#125; Or even just one line 1return letters[(upper_bound(letters.begin(), letters.end(), target)-letters.begin())%letters.size()]; [2023-09-26 Tue 14:50] This solution is inspired by find max square root of x. We store an intermediate variable. Notice that the candidate answer is always in “greater branch”, thus in that branch, we store the candidate mid. 1234567891011121314151617181920212223242526272829class Solution &#123;public: char nextGreatestLetter(vector&lt;char&gt;&amp; letters, char target) &#123; int N=letters.size(); int ans=0; int low=0, high=N-1; while(low&lt;=high) &#123; int mid=(low+high)&gt;&gt;1; if (letters[mid] == target &amp;&amp; mid+1 &lt; N &amp;&amp; letters[mid+1] &gt; target) &#123; return letters[mid+1]; &#125; if (letters[mid]&lt;=target) &#123; low=mid+1; &#125; else &#123; // greater branch high=mid-1; ans=mid; &#125; &#125; //not found if(letters[ans]&lt;=target) &#123; ans=0; &#125; return letters[ans]; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"easy","slug":"easy","permalink":"https://illuca.github.io/tags/easy/"},{"name":"binary-search","slug":"binary-search","permalink":"https://illuca.github.io/tags/binary-search/"}]},{"title":"214. Shortest Palindrome","slug":"214. Shortest Palindrome","date":"2023-05-20T16:00:00.000Z","updated":"2023-11-02T09:24:17.357Z","comments":true,"path":"2023/05/21/214. Shortest Palindrome/","link":"","permalink":"https://illuca.github.io/2023/05/21/214.%20Shortest%20Palindrome/","excerpt":"","text":"https://leetcode.com/problems/shortest-palindrome/ You are given a string s. You can convert s to a palindrome by adding characters in front of it. Return the shortest palindrome you can find by performing this transformation. Example 1: 12Input: s = &quot;aacecaaa&quot;Output: &quot;aaacecaaa&quot; Example 2: 12Input: s = &quot;abcd&quot;Output: &quot;dcbabcd&quot; Constraints: 0 &lt;= s.length &lt;= 5 * 104 s consists of lowercase English letters only. Firstly, i use brute method to solve it, but get Time Limit. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution &#123;public: void change(int &amp;left, int &amp;right) &#123; bool isEven = (left+right)%2==0; if(isEven)&#123; right--; &#125;else&#123; left--; &#125; &#125; string shortestPalindrome(string s) &#123; //there is a string s. I need to add chs to convert it to a palindrome. //I only can add chs in front of s. //There many ways to form a palindrome by adding chs. But you must add fewest chs so that you get the shortest palindrome. //find the center ch. check if the chs on both sides are equal. Cal the num of chs that equal. //it must cannot meet any ch that does not equal //loop util one pointer arrives bound // init mid and let it close to left end; int n=s.size(); int left, right; int mid=n/2; if(n%2==1) &#123; left=mid-1; right=mid+1; &#125;else&#123; left=mid-1; right=mid; &#125; int start=0; while(1) &#123; int pleft=left, pright=right; //initial value for pleft and pright in every loop while(1) &#123; // loop util pleft arrives bound or appear not equal if(pleft &lt; 0 || s[pleft]!=s[pright]) &#123; break; &#125; pleft--; pright++; &#125; //if left does not arrive bound, then mid-- if(pleft&gt;=0)&#123; change(left, right); &#125; else&#123; start=pright; break; &#125; &#125; // add [start, end].reverse to s string sub=s.substr(start, n-1-start+1); for(int i=0; i&lt;sub.size(); i++)&#123; s=sub[i]+s; &#125; return s; &#125;&#125;; Actually, this problem can be converted to find the longest common part and we only need the last comparison. We compare [0:matched]==[i-matched, i] We can use KMP to boost the process. Otherwise, every time we fail to match s[matched] and s[i]. We need to set i as N-1 and reset matched as 0. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: void buildArray(string &amp;s, vector&lt;int&gt; &amp;back) &#123; back[0] = 0; for (int len = 0, i = 1; i &lt; s.size();) &#123; if (s[len] == s[i]) &#123; //match then increase both and set table // len means the num of matched back[i] = len + 1; len++; i++; &#125; else &#123; if (len==0) &#123; i++; &#125; else &#123; len = back[len - 1]; &#125; &#125; &#125; &#125; string shortestPalindrome(string s) &#123; if (s.empty()) &#123; return s; &#125; int N = s.size(); vector&lt;int&gt; back(N); buildArray(s, back); int matched = 0; for (int i = N - 1; i &gt;= 0;) &#123; //check if match then increase if (s[matched] == s[i]) &#123; matched++; i--; &#125; else &#123; //reset matched if (matched==0) &#123; i--; &#125; else &#123; matched = back[matched - 1]; &#125; &#125; &#125; //sub=[matched:] string sub = s.substr(matched); reverse(sub.begin(),sub.end()); s=sub+s; return s; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"KMP","slug":"KMP","permalink":"https://illuca.github.io/tags/KMP/"}]},{"title":"704. Binary Search","slug":"704. Binary Search","date":"2023-05-20T16:00:00.000Z","updated":"2023-05-22T03:40:50.097Z","comments":true,"path":"2023/05/21/704. Binary Search/","link":"","permalink":"https://illuca.github.io/2023/05/21/704.%20Binary%20Search/","excerpt":"","text":"https://leetcode.com/problems/binary-search/description/ Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity. Example 1: 123Input: nums = [-1,0,3,5,9,12], target = 9Output: 4Explanation: 9 exists in nums and its index is 4 Example 2: 123Input: nums = [-1,0,3,5,9,12], target = 2Output: -1Explanation: 2 does not exist in nums so return -1 Constraints: 1 &lt;= nums.length &lt;= 104 -104 &lt; nums[i], target &lt; 104 All the integers in nums are unique. nums is sorted in ascending order. 1234567891011121314151617181920class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int N=nums.size(); for(int left=0, right=N-1, mid=(right+left)&gt;&gt;1;left &lt;= right;)&#123; //loop util nums[mid]==target //if len is 0 then break if(target==nums[mid])&#123; return mid; &#125; else if(target&lt;nums[mid])&#123; right=mid-1; mid=(left+right)&gt;&gt;1; &#125;else&#123; left=mid+1; mid=(left+right)&gt;&gt;1; &#125; &#125; return -1; &#125;&#125;; This problem is easy, but pay attention to mid=(left+right)&gt;&gt;1; For this problem, 1&lt;=nums.length&lt;=104, so it should be fine. However, if the length is very large, then left+right may be overflow. To solve overflow, we use mid=left+((right-left)&gt;&gt;1); or mid = ((unsigned int)low + (unsigned int)high)) &gt;&gt; 1; You can find more details on https://ai.googleblog.com/2006/06/extra-extra-read-all-about-it-nearly.html.","categories":[],"tags":[{"name":"leetcode binary-search","slug":"leetcode-binary-search","permalink":"https://illuca.github.io/tags/leetcode-binary-search/"}]},{"title":"KMP","slug":"KMP","date":"2023-05-19T16:00:00.000Z","updated":"2023-11-02T09:20:53.634Z","comments":true,"path":"2023/05/20/KMP/","link":"","permalink":"https://illuca.github.io/2023/05/20/KMP/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int getLongestCommonPartSize(string &amp;pat, int len) &#123; // For each sub string, we have [0, end-1-i], [1+i, end] for (int i = 0; i &lt; len - 1; i++) &#123; //check if prefix[m]==suffix[m] int m = 0; int suffixLen = len - 1 - i; for (; m &lt; suffixLen; m++) &#123; if (pat[m] != pat[1 + i + m]) &#123; break; &#125; &#125; if (m == suffixLen) &#123; // match return m; &#125; &#125; return 0;&#125;void KMPSearch(string &amp;pat, string &amp;txt) &#123; //construct suffix table //suffix table has the same size as pat //ababa //0 a //0 ab //1 aba //2 abab int suffix[pat.size()]; suffix[0] = -1; // we totally have pat.size()-1 sub string //i is the size of substring for (int len = 1; len &lt; pat.size(); len++) &#123; suffix[len] = getLongestCommonPartSize(pat, len); &#125; //check if pat[j]==txt[i] int j = 0, i = 0; while (1) &#123; //break if one of the pointers overflow //if match, then both pointer++ //else: check if can move(big&#x27;s pointer+small&#x27;s size==big&#x27;s size) // move pat to where fails //set pat&#x27;s p as suffix[p] if (i &gt;= txt.size()) &#123; break; &#125; if (j &gt;= pat.size()) &#123; cout &lt;&lt; i - pat.size() &lt;&lt; endl; j = 0; &#125; if (pat[j] == txt[i]) &#123; j++; i++; &#125; else &#123; // check can move if (i + pat.size() == txt.size()) &#123; break; &#125; if (suffix[j] == -1) &#123; i++; j = 0; &#125; else &#123; j = suffix[j]; &#125; &#125; &#125; if (j &gt;= pat.size()) &#123; cout &lt;&lt; i - pat.size() &lt;&lt; endl; &#125;&#125;int main() &#123; string txt = &quot;ABABDABACDABABCABAB&quot;; string pat = &quot;ABABCABAB&quot;; KMPSearch(pat, txt); return 0;&#125; The size of pat is M. The process of build suffix table is O(M^2), we need to optimize it. There are ways of implementing the loop. One way is: 12345678910111213141516//if matched then increase both pointers and set table//else go back to find previous matched to startfor(int len=0, i=1;i&lt;s.size();)&#123; if (s[len] == s[i]) &#123; len++; back[i] = len; i++; &#125; else &#123; if (len==0) &#123; i++; &#125; else &#123; len = back[len - 1]; &#125; &#125;&#125; Another is: 1234567891011121314//loop util find a character matchedfor(int len=0, i=1;i&lt;s.size();)&#123; while(len&gt;=1&amp;&amp;s[i]!=s[len])&#123; len=back[len-1]; &#125; if(len&lt;1&amp;&amp;s[i]!=s[len]) &#123; i++; &#125;else&#123; //matched len++; back[i]=len; i++; &#125;&#125; The prefix and suffix are like two eras before and after, all conditions are the same, but at a certain point in time, the latter era B is destroyed. Therefore, era A, at that point, needs to make a different move than B to possibly succeed. Era A = [Common Part + Different Part]Era B = [Common Part] Well, may be the DFA(deterministic finite automaton) can give me another angle to understand KMP. https://www.youtube.com/watch?v=hBXzOq_1yRk","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"KMP","slug":"KMP","permalink":"https://illuca.github.io/tags/KMP/"}]},{"title":"2013. Detect Squares","slug":"2013. Detect Squares","date":"2023-05-17T16:00:00.000Z","updated":"2023-05-18T13:11:41.529Z","comments":true,"path":"2023/05/18/2013. Detect Squares/","link":"","permalink":"https://illuca.github.io/2023/05/18/2013.%20Detect%20Squares/","excerpt":"","text":"Note: Pay attention to array bound. You’d better plus 1 to array size. In this problem, 0&lt;=x,y&lt;=1000. So I should init array size as 1000+1; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;map&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;using namespace std;class DetectSquares &#123;public: map&lt;int, vector&lt;pair&lt;int,int&gt;&gt;&gt; mapY; int counter[1001][1001]=&#123;&#125;; void add(vector&lt;int&gt; point) &#123; int pointx=point[0]; int pointy=point[1]; if(counter[pointx][pointy] == 0)&#123; //only insert once mapY[pointy].emplace_back(pointx, pointy); &#125; counter[pointx][pointy]++; &#125; int count(vector&lt;int&gt; query) &#123; int queryx=query[0], queryy=query[1]; vector&lt;pair&lt;int,int&gt;&gt; arrY=mapY[query[1]]; int res=0; //arry does not have duplicate items for(int i = 0; i&lt;arrY.size(); i++)&#123; pair&lt;int,int&gt; p = arrY[i]; int px=p.first,py=p.second; int edge=abs(queryx-px); if(edge==0) &#123; continue; &#125; int y=queryy+edge; int _y=queryy-edge; if (y&gt;=0 &amp;&amp; y&lt;=1000 ) &#123; //up=[queryx,y] //upDia=[px,y] res+= counter[px][py] * counter[queryx][y] * counter[px][y]; &#125; if (_y&gt;=0 &amp;&amp; _y&lt;=1000) &#123; //down=[queryx,_y] //downDia=[px,_y] res+= counter[px][py] * counter[queryx][_y] * counter[px][_y]; &#125; &#125; return res; &#125;&#125;; I think it can be more clear because diagonal point is more special than point with the same x as query. And if we get the diagonal point, it is easier to express two other points. 123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdlib&gt;#include &lt;vector&gt;using namespace std;class DetectSquares &#123;public: vector&lt;pair&lt;int,int&gt;&gt; points; int counter[1001][1001]=&#123;&#125;; void add(vector&lt;int&gt; point) &#123; int pointX=point[0]; int pointY=point[1]; if(counter[pointX][pointY] == 0)&#123; //only insert once points.emplace_back(pointX, pointY); &#125; counter[pointX][pointY]++; &#125; int count(vector&lt;int&gt; query) &#123; int queryX=query[0], queryY=query[1]; int res=0; for(auto &amp;[diagX, diagY]: points)&#123; if(abs(diagX-queryX)!=abs(diagY-queryY) || diagX-queryX==0) &#123; continue; &#125;else&#123; //m has the same x as diag and same y as query //m(diagX, queryY) //n(queryX, diagY) res+=counter[diagX][queryY]*counter[queryX][diagY]*counter[diagX][diagY]; &#125; &#125; return res; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"}]},{"title":"1055. Shortest Way to Form String","slug":"1055. Shortest Way to Form String","date":"2023-05-15T16:00:00.000Z","updated":"2023-05-18T13:13:01.516Z","comments":true,"path":"2023/05/16/1055. Shortest Way to Form String/","link":"","permalink":"https://illuca.github.io/2023/05/16/1055.%20Shortest%20Way%20to%20Form%20String/","excerpt":"","text":"https://leetcode.com/problems/shortest-way-to-form-string/description/ A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., &quot;ace&quot; is a subsequence of &quot;abcde&quot; while &quot;aec&quot; is not). Given two strings source and target, return the minimum number of subsequences of source such that their concatenation equals target. If the task is impossible, return -1. Example 1: 123Input: source = &quot;abc&quot;, target = &quot;abcbc&quot;Output: 2Explanation: The target &quot;abcbc&quot; can be formed by &quot;abc&quot; and &quot;bc&quot;, which are subsequences of source &quot;abc&quot;. Example 2: 123Input: source = &quot;abc&quot;, target = &quot;acdbc&quot;Output: -1Explanation: The target string cannot be constructed from the subsequences of source string due to the character &quot;d&quot; in target string. Example 3: 123Input: source = &quot;xyz&quot;, target = &quot;xzyxz&quot;Output: 3Explanation: The target string can be constructed as follows &quot;xz&quot; + &quot;y&quot; + &quot;xz&quot;. Constraints: 1 &lt;= source.length, target.length &lt;= 1000 source and target consist of lowercase English letters. 12345678910111213141516171819202122232425262728class Solution &#123;public: int shortestWay(string source, string target) &#123; //explain subsequence. it is a special string that remain relative position in original string //we use sub of source and use them to form target //traverse target and for each target[i] try to find matched ch in source. so we need to traverse source. //traverse source //if find matched ch in source, then increase both string index and try to find next match ch //if in current loop, num of matched is 0, then return -1 //otherwise i+=num of matched int loops=0; for(int i=0;i&lt;target.size();)&#123; int matched=0; for(int j=0;j&lt;source.size();j++)&#123; if(target[i+matched]==source[j])&#123; matched++; &#125; &#125; if(matched==0)&#123; return -1; &#125;else&#123; i+=matched; loops++; &#125; &#125; return loops; &#125;&#125;; Beats 100% and only one submit no debug. It seems finally i grasp some trick? Amazing.","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"}]},{"title":"1101. The Earliest Moment When Everyone Become Friends","slug":"1101. The Earliest Moment When Everyone Become Friends","date":"2023-05-14T16:00:00.000Z","updated":"2023-05-16T12:01:05.321Z","comments":true,"path":"2023/05/15/1101. The Earliest Moment When Everyone Become Friends/","link":"","permalink":"https://illuca.github.io/2023/05/15/1101.%20The%20Earliest%20Moment%20When%20Everyone%20Become%20Friends/","excerpt":"","text":"There are n people in a social group labeled from 0 to n - 1. You are given an array logs where logs[i] = [timestampi, xi, yi] indicates that xi and yi will be friends at the time timestampi. Friendship is symmetric. That means if a is friends with b, then b is friends with a. Also, person a is acquainted with a person b if a is friends with b, or a is a friend of someone acquainted with b. Return the earliest time for which every person became acquainted with every other person. If there is no such earliest time, return -1. Example 1: 123456789Input: logs = [[20190101,0,1],[20190104,3,4],[20190107,2,3],[20190211,1,5],[20190224,2,4],[20190301,0,3],[20190312,1,2],[20190322,4,5]], n = 6Output: 20190301Explanation: The first event occurs at timestamp = 20190101, and after 0 and 1 become friends, we have the following friendship groups [0,1], [2], [3], [4], [5].The second event occurs at timestamp = 20190104, and after 3 and 4 become friends, we have the following friendship groups [0,1], [2], [3,4], [5].The third event occurs at timestamp = 20190107, and after 2 and 3 become friends, we have the following friendship groups [0,1], [2,3,4], [5].The fourth event occurs at timestamp = 20190211, and after 1 and 5 become friends, we have the following friendship groups [0,1,5], [2,3,4].The fifth event occurs at timestamp = 20190224, and as 2 and 4 are already friends, nothing happens.The sixth event occurs at timestamp = 20190301, and after 0 and 3 become friends, we all become friends. Example 2: 123Input: logs = [[0,2,0],[1,0,1],[3,0,3],[4,1,2],[7,3,1]], n = 4Output: 3Explanation: At timestamp = 3, all the persons (i.e., 0, 1, 2, and 3) become friends. Constraints: 2 &lt;= n &lt;= 100 1 &lt;= logs.length &lt;= 104 logs[i].length == 3 0 &lt;= timestampi &lt;= 109 0 &lt;= xi, yi &lt;= n - 1 xi != yi All the values timestampi are unique. All the pairs (xi, yi) occur at most one time in the input. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution &#123;public: int findRoot(vector&lt;int&gt; &amp;parent, int x) &#123; // keep find next util next is -1 int curr = x; while (1) &#123; int next = parent[curr]; if (next == -1) &#123; return curr; &#125; else &#123; curr = next; &#125; &#125; &#125; static bool compare(vector&lt;int&gt;&amp;v1, vector&lt;int&gt;&amp;v2) &#123; return v1[0] &lt; v2[0]; &#125; int earliestAcq(vector&lt;vector&lt;int&gt;&gt; &amp;logs, int n) &#123; // init a nodes array, every time connect two parent, we firstly find root of i, and parent[root]=j // remove j from leaves // if all leaves have same root, then return time. // otherwise, keep traversing logs sort(logs.begin(), logs.end(), compare); vector&lt;int&gt; parent(n, -1); set&lt;int&gt; leaves; set&lt;int&gt; seen; for (int i = 0; i &lt; logs.size(); i++) &#123; int x = logs[i][1]; int y = logs[i][2]; seen.insert(x); seen.insert(y); int root = findRoot(parent, x); // if root is itself, it is a leaf if(findRoot(parent,y) == root) &#123; continue; &#125; if (x == root) &#123; leaves.insert(x); &#125; parent[root] = y; leaves.erase(y); if (seen.size() == n) &#123; int curr_root = findRoot(parent, 0); bool connected = true; for (auto item: leaves) &#123; if(curr_root!=findRoot(parent, item))&#123; connected=false; break; &#125; &#125; if (connected) &#123; return logs[i][0]; &#125; &#125; &#125; return -1; &#125;&#125;; After optimization: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;algorithm&gt;using namespace std;class Solution &#123; vector&lt;int&gt; parent; vector&lt;int&gt; rank;public: int findRoot(int x)&#123; // keep find next util curr is itself if(parent[x]==x) &#123; return x; &#125; else &#123; return findRoot(parent[x]); &#125; &#125; int earliestAcq(vector&lt;vector&lt;int&gt;&gt; &amp;logs, int n) &#123; // sort logs by time // init a parent array, every time we connect two people, we exec parent[root of i]=j // but we firstly check if i and j has been connected already. // namely find the root of j and compare it with root of i // if they equal, then they are connected. // we find root of i and parent[root]=j sort(logs.begin(), logs.end()); parent.resize(n,0); for(int i=0;i&lt;n;i++)&#123; parent[i]=i; &#125; rank.resize(n,0); int groups=n; for(int i=0;i&lt;logs.size();i++)&#123; int x=logs[i][1]; int y=logs[i][2]; int rootx=findRoot(x); int rooty=findRoot(y); if (rootx==rooty) &#123; continue; &#125; // At first, there are n independent person. if two root are not equal, then merge two groups // when only 1 group left, all people are connected // let node with higher rank be the parent if(rank[rootx]==rank[rooty])&#123; parent[rootx]=rooty; rank[rooty]++; &#125; else if(rank[rootx]&lt;rank[rooty])&#123; parent[rootx]=rooty; &#125; else if(rank[rootx]&gt;rank[rooty]) &#123; parent[rooty]=rootx; &#125; groups--; if(groups==1)&#123; return logs[i][0]; &#125; &#125; // does not exist that time return -1; &#125;&#125;; If rooty is root, its rank will be increased.Then it will be more likely to be parent. The graph looks like a star and the root is in the center.","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"}]},{"title":"Longest Palindromic Substring","slug":"Longest Palindromic Substring","date":"2023-05-13T16:00:00.000Z","updated":"2023-05-15T10:17:34.651Z","comments":true,"path":"2023/05/14/Longest Palindromic Substring/","link":"","permalink":"https://illuca.github.io/2023/05/14/Longest%20Palindromic%20Substring/","excerpt":"","text":"Given a string s, return the longest palindromic substring in s. Example 1: 123Input: s = &quot;babad&quot;Output: &quot;bab&quot;Explanation: &quot;aba&quot; is also a valid answer. Example 2: 12Input: s = &quot;cbbd&quot;Output: &quot;bb&quot; Constraints: 1 &lt;= s.length &lt;= 1000 s consist of only digits and English letters. This is my solution 1. 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;algorithm&gt;using namespace std;class Solution &#123;public: bool isPalindrome(string &amp;s, int index, int len) &#123; //s[i]==s[s.size()-1-i] //s[0]==s[s.size()-1] int begin = index, end = index + len - 1; while (begin &lt; end) &#123; if (s[begin] != s[end]) &#123; return false; &#125; else &#123; begin++; end--; &#125; &#125; return true; &#125; string longestPalindrome(string s) &#123; // for each s[i,j], we judge if it is palindrome. // if it is palindrome, then compare it with previous max length. int maxm = 1; string res; int start = 0; for (int i = 0; i &lt; s.size(); i++) &#123; // if has got a palindrome, then the next must bigger than current // j means length of substring for (int j = max(2, maxm); i + j - 1 &lt; s.size(); j++) &#123; if (isPalindrome(s, i, j)) &#123; if (maxm &lt; j) &#123; start = i; maxm = j; &#125; &#125; &#125; &#125; return s.substr(start, maxm); &#125;&#125;; Although using dynamic programming costs more time in leetcode, i still consider it is a good idea. This solution is referring to a solution in leetcode. After understanding that solution, i try to write code from my memory to check if i really undertstand. But i found it is too hard to understand his loop variable. Thus i just follow my heart and use recursive to solve that problem. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657using namespace std;class Solution &#123;public: int isPalindrome(int dp[][1000], int i, int j, string &amp;s) &#123; if (i == j) &#123; dp[i][j] = 1; &#125; else if (i + 1 == j) &#123; // &#x27;bb&#x27; dp[i][j] = s[i] == s[j]; &#125; else &#123; if (dp[i + 1][j - 1] == -1) &#123; dp[i][j] = s[i] == s[j] &amp;&amp; isPalindrome(dp, i + 1, j - 1, s); &#125; else &#123; dp[i][j] = s[i] == s[j] &amp;&amp; dp[i + 1][j - 1] == 1; &#125; &#125; return dp[i][j]; &#125; string longestPalindrome(string s) &#123; // init an array, dp[i][j]. int n = s.size(); int dp[1000][1000]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; dp[i][j] = -1; &#125; &#125; // i means begin of the substring while j means end of the substring // dp[0][0]=true means s.substr(0,1) is palindrome // dp[0][3]=true means s.substr(0,4) is palindrome // dp[0][3]=s[0]==s[3] &amp;&amp; dp[1][2] // dp[1][2]=s[1]==s[2] // thus dp[i][j]=s[i]==s[j] &amp;&amp; dp[i+1][j-1], i+1 &lt;= j-1 // we check all the possibilities of substring int max_len = 0; int max_begin = 0, max_end = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = i; j &lt; n; j++) &#123; // check if substring(i,j) is palindrome if (isPalindrome(dp, i, j, s)) &#123; int curr_len = j - i + 1; if (curr_len &gt; max_len) &#123; max_len = curr_len; max_begin = i; max_end = j; &#125; &#125; &#125; &#125; // record begin and end of the max substring return s.substr(max_begin, max_end - max_begin + 1); &#125;&#125;; I guess it is the best solution. It is really efficient. https://leetcode.com/problems/longest-palindromic-substring/solutions/3401644/detailed-recursive-explaination-with-pictures-in-c-java-python-dp-two-pointers/ 1234567891011121314151617181920212223class Solution &#123;public: string ans = &quot;&quot;; void expand(string &amp;s , int left ,int right) &#123; while(left &gt;= 0 &amp;&amp; right &lt; s.size()) &#123; if(s[left] != s[right]) break; left--,right++; &#125; if(ans.size() &lt; right - left ) ans = s.substr(left + 1 , right - left - 1); &#125; string longestPalindrome(string s) &#123; for(int i = 0 ; i &lt; s.size() ; i++) &#123; expand(s , i , i); expand(s , i , i+1); &#125; return ans; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"}]},{"title":"COMP9315 DBMS Implementation","slug":"COMP9315","date":"2023-05-12T16:00:00.000Z","updated":"2024-01-09T04:46:12.450Z","comments":true,"path":"2023/05/13/COMP9315/","link":"","permalink":"https://illuca.github.io/2023/05/13/COMP9315/","excerpt":"","text":"Since i have no course to choose, so i have to choose this one. On the other hand, this course can help me to understand better about database. Although this course is called Database Implementation, it does not teach you how to write a database application. Instead, the course is full of various algorithms, taking Postgre as example. The quiz almost does not change every year. It aims to help you check whether you grasp the knowledge taught on lectures. Assessment 1For assessment 1, it needs you to implement a new type called gcoord. You can get more details on https://cgi.cse.unsw.edu.au/~cs9315/23T1/assignment/1/index.php. Note 1: Because C Postgre library has special processing on struct storage. You should follow the document standard. 12345678typedef struct GeoCoord&#123; double latitude_value; double longitude_value; char latitude_direction; char longitude_direction; char location_name[FLEXIBLE_ARRAY_MEMBER];&#125; GeoCoord; As shown above, variable-length variable must be declared at the end of the struct. You can get more details on https://www.postgresql.org/docs/current/xfunc-c.html. Even though you don’t pay attention to this special usage, malloc can also helps you pass lots of tests provided by the convener. Note 2: This problem is about precision. For function Convert2DMS: 1234It converts the greographical coordinates from decimal to DMS(degree, minute, second). The calculation can be described as:D = floor(Ddec),M = floor(60 × |Ddec-D|),S = floor(3600 × |Ddec-D| - 60 × M), Because latitude_value in my struct is double and double will cause precision loss when executing operation like: 123456int main() &#123; double x = 73.55; int result = (int)((x - 73) * 60); printf(&quot;result: %d&quot;, result); // result: 32 return 0;&#125; The result should be 33 but program gives us 32. Since the coordinate value do not have more than 4 decimal places, so we can solve it as shown below: 123456789101112131415161718192021222324double myround(double x) &#123; double result = (x-round(x)); if (fabs(result) &lt; 0.0001) &#123; return round(x); &#125; else &#123; return x; &#125;&#125;void DMS(char *string, double value, char direction) &#123; int d_dec, degree, minute, second; double diff; degree = (int) floor(value); diff = (value - degree); minute = (int) floor(myround(60*diff)); second = (int) floor(myround(3600*diff - 60 * minute)); if (minute == 0) &#123; sprintf(string, &quot;%d°%c&quot;, degree, direction); &#125; else if (second == 0) &#123; sprintf(string, &quot;%d°%d&#x27;%c&quot;, degree, minute, direction); &#125; else &#123; sprintf(string, &quot;%d°%d&#x27;%d\\&quot;%c&quot;, degree, minute, second, direction); &#125;&#125; But my friend has better idea: 123456typedef struct GeoCoord &#123; int latitude; int longitude;&#125;latitude = (int)((x * 10000) + 0.5);longitude = (int)((y * 10000) + 0.5); Note 3: Because latitude and longitude in my struct are double and double is 64 bit. So we need 64-bit hash. 1234567891011121314151617181920212223242526static uint32_thash_uint64(uint64_t key)&#123; key = (~key) + (key &lt;&lt; 21); key = key ^ (key &gt;&gt; 24); key = key + (key &lt;&lt; 3) + (key &lt;&lt; 8); key = key ^ (key &gt;&gt; 14); key = key + (key &lt;&lt; 2) + (key &lt;&lt; 4); key = key ^ (key &gt;&gt; 28); key = key + (key &lt;&lt; 31); return (uint32_t)key;&#125;PG_FUNCTION_INFO_V1(gcoord_hash);Datumgcoord_hash(PG_FUNCTION_ARGS)&#123; GeoCoord* coord = (GeoCoord*)PG_GETARG_POINTER(0); uint32_t hash = 0; hash ^= (uint32_t) strlen(coord-&gt;location_name); hash ^= hash_uint64(coord-&gt;latitude_value); hash ^= hash_uint64(coord-&gt;longitude_value); hash ^= (uint32_t) coord-&gt;latitude_direction; PG_RETURN_UINT32(hash);&#125; I think it is too tricky and there should be a better solution. Assessment 2The second ass needs you to implement operation Sel and Join. You can find more details on https://cgi.cse.unsw.edu.au/~cs9315/23T1/assignment/2/. Note1: read page from file You need to read page from file and for each page, you read tuple from it. 1234567891011121314for (int page_idx = 0; page_idx &lt; total_page; page_idx++) &#123; buffer* buffer_p = request_page(t, page_idx); for (int tid = 0; tid &lt; get_tuples_num(buffer_p); tid++) &#123; Tuple tuple = get_tuple_by_tuple_id(buffer_p, tid); if (tuple[idx] == cond_val) &#123; result-&gt;tuples[counter++] = tuple; &#125; else &#123; free(tuple); &#125; &#125; release_page(buffer_p); log_release_page(buffer_p-&gt;page_id);&#125; The thought seems simple but i didn’t come out at the beginning. I read all pages from files and then read tuples from pages. Note2: buffer pool Take Sel as example. We check whether current page is stored in buffer pool and if it has been stored, then just read it from pool. Otherwise, we read page from file by page index and then store the page in pool. When storing page in pool, we check whether the number of pages is greater than the buffer limit. If it is greater than buffer limit, then we use buffer replacement to replace page. Otherwise, we directly store the page in buffer pool. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748buffer* request_page(Table* t, int page_index) &#123; buffer* buffers = buffer_pool-&gt;buffers; int slot = page_in_pool(t-&gt;oid, page_index); UINT buffer_size = buffer_pool-&gt;nbufs; UINT* nvb_p = &amp;buffer_pool-&gt;nvb; if (slot &gt;= 0) &#123; buffers[slot].usage++; buffers[slot].pin = 1; buffer_pool-&gt;nhits++; return &amp;buffers[slot]; &#125; while (1) &#123; if (buffers[*nvb_p].pin == 0 &amp;&amp; buffers[*nvb_p].usage == 0) &#123; write_page_to_buffer_pool(t, *nvb_p, page_index); UINT tmp = *nvb_p; *nvb_p = (*nvb_p + 1) % buffer_size; return &amp;buffers[tmp]; &#125; else &#123; if (buffers[*nvb_p].usage &gt; 0) buffers[*nvb_p].usage--; *nvb_p = (*nvb_p + 1) % buffer_size; &#125; &#125;&#125;void write_page_to_buffer_pool(Table* t, UINT slot, UINT page_index) &#123; FileInfo* file_info = open_file_by_table_name(t-&gt;name); FILE* fp = file_info-&gt;file; UINT page_size = get_conf()-&gt;page_size; fseek(fp, page_index * page_size, SEEK_SET); fread(buffer_pool-&gt;buffers[slot].page, page_size, 1, fp); log_read_page(get_page_id(buffer_pool-&gt;buffers[slot].page)); buffer_pool-&gt;nreads++; UINT64 page_id; memcpy(&amp;page_id, buffer_pool-&gt;buffers[slot].page, sizeof(UINT64)); sprintf(buffer_pool-&gt;buffers[slot].id, &quot;%u-%lu&quot;, t-&gt;oid, page_id); buffer_pool-&gt;buffers[slot].oid = t-&gt;oid; memcpy(buffer_pool-&gt;buffers[slot].table, t, sizeof(Table)); buffer_pool-&gt;buffers[slot].page_index = page_index; buffer_pool-&gt;buffers[slot].page_id = page_id; buffer_pool-&gt;buffers[slot].usage = 1; buffer_pool-&gt;buffers[slot].pin = 1; release_file(file_info);&#125; For request_page, it implements the clock-sweep strategy which is the Postgre default buffer replacement policy. Note3: file pool Because we have the limit for the number of opened files. So we need to maintain a file pool. If we want to read or write a page from file, we firstly check whether the file pointer has been stored in file pool by oid. If it has been stored, then we use it directly. Otherwise, we check whether the num of opened files is greater than the file limit. If it is greater than file limit, we use buffer replacement strategy the same as buffer pool. If not, we open a new file and store related oid in file pool. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748FileInfo* open_file_by_table_name(const char* table_name) &#123; Database* db = get_db(); Table* t = get_table(table_name); char* table_path = (char*) malloc(sizeof(db-&gt;path) + 5); sprintf(table_path, &quot;%s/%u&quot;, db-&gt;path, t-&gt;oid); FileInfo* result = request_file(table_path, &quot;r&quot;, t-&gt;oid); free(table_path); free(t); return result;&#125;FileInfo* request_file(const char* filename, const char* mode, UINT oid) &#123; FileInfo* buffers = file_pool-&gt;buffers; int slot = file_in_pool(oid); UINT buffer_size = file_pool-&gt;nbufs; UINT* nvb_p = &amp;file_pool-&gt;nvb; if (slot &gt;= 0) &#123; buffers[slot].usage++; buffers[slot].pin = 1; return &amp;buffers[slot]; &#125; while (1) &#123; if (buffers[*nvb_p].pin == 0 &amp;&amp; buffers[*nvb_p].usage == 0) &#123; open_file_in_pool(*nvb_p, filename, mode, oid); UINT tmp = *nvb_p; *nvb_p = (*nvb_p + 1) % buffer_size; return &amp;buffers[tmp]; &#125; else &#123; if (buffers[*nvb_p].usage &gt; 0) buffers[*nvb_p].usage--; *nvb_p = (*nvb_p + 1) % buffer_size; &#125; &#125;&#125;void open_file_in_pool(UINT slot, const char* filename, const char* mode, UINT oid) &#123; if (file_pool-&gt;num_opened_files &gt;= file_pool-&gt;nbufs) &#123; close_file_in_pool(slot); &#125; file_pool-&gt;buffers[slot].file = fopen(filename, mode); log_open_file(oid); file_pool-&gt;buffers[slot].oid = oid; file_pool-&gt;buffers[slot].pin = 1; file_pool-&gt;buffers[slot].usage = 1; file_pool-&gt;num_opened_files++;&#125; Note4: valgrind The tool is used to check memory leak. It also can check error like: 1234char* result = (char*) malloc(tuple_size);memcpy(result, curr, tuple_size);Address 0x4a40299 is 0 bytes after a block of size 25 alloc&#x27;d For the code above, it should be written as below because the last byte is for \\0. 12char* result = (char*) malloc(tuple_size+1);memcpy(result, curr, tuple_size+1); Final exam3 programs are all about assessment2. It is not difficult but it is really hard to figure it out in 3 hours because we have another 5 questions to do. Q1Note1: convert big tuple to small tuple Q2I forgot to use r+. So funny…as a result, i write nothing back to the file. ConclusionThe course has challenging assessment. Ass1 strengthens my ability to collect information from official documents. Ass2 makes me have better understanding of clock sweep, simple hash join and merge sort join. It also enhances the ability to maintain C pointer.","categories":[],"tags":[{"name":"UNSW","slug":"UNSW","permalink":"https://illuca.github.io/tags/UNSW/"},{"name":"notes","slug":"notes","permalink":"https://illuca.github.io/tags/notes/"}]},{"title":"ANZAC CONTEST 1","slug":"ANZAC-CONTEST-1","date":"2023-03-24T16:00:00.000Z","updated":"2024-01-09T04:46:09.657Z","comments":true,"path":"2023/03/25/ANZAC-CONTEST-1/","link":"","permalink":"https://illuca.github.io/2023/03/25/ANZAC-CONTEST-1/","excerpt":"","text":"A 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;unordered_map&gt;#include&lt;unordered_set&gt;using namespace std;int main() &#123; int N; cin &gt;&gt; N; // init an unordered map. unordered_map&lt;int, int&gt; map; unordered_set&lt;int&gt; values; map[0] = 0; map[1] = 1; // keep cal fib until if fib number &gt; N int i = 2; while (1) &#123; //cal fib util fib number &gt; N int fib = map[i - 1] + map[i - 2]; if (fib &gt; N) &#123; break; &#125; map[i] = fib; values.insert(fib); //cal next i++; &#125; for (int i = 1; i &lt;= N; i++) &#123; if (values.count(i)) &#123; cout &lt;&lt; &quot;fizz&quot;; &#125; else &#123; cout &lt;&lt; &quot;buzz&quot;; &#125; &#125;&#125; B 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; // input two numbers // first is the number to insert // second is the original number // our aim is to insert at a certain location to make the output biggest // find the first num that less than number to insert. 789 6-&gt;7896, 749 5-&gt;7549 // 749 0-&gt;7490 // 0 0 -&gt;0 int x; string number; cin &gt;&gt; x; cin &gt;&gt; number; vector&lt;int&gt; result; bool inserted = false; for (int i = 0; i &lt; number.size(); i++) &#123; int curr = number[i] - &#x27;0&#x27;; if (curr &lt;= x &amp;&amp; !inserted) &#123; number.insert(i, to_string(x)); inserted = true; break; &#125; result.push_back(curr); &#125; if (!inserted) &#123; number.push_back(&#x27;0&#x27; + x); &#125; cout &lt;&lt; number &lt;&lt; endl; return 0;&#125; CTake 20 as example:20=17+3=13+717-3 has biggest diff.14=11-3=8 step=18=5+3 step=25-3=2 step=3 First we has two pointers, left is 2 and right is x-1;break: if left greater than right or left+right=x and right-left is even.Then set x as right-left and loop again util right-left is 2 or 0. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;using namespace std;bool isPrime(int num) &#123; // divide num into 2 part like 11/2+1=6, i=[2,5] // 12/2+1=7,i=[2,6] // 1/2+1=1 if (num==1) &#123; return false; &#125; for (int i = 2; i &lt; num / 2 + 1; i++) &#123; if (num % i == 0) &#123; return false; &#125; &#125; return true;&#125;void getPrime(int &amp;left, int &amp;right, int x) &#123; //loop util right - left is even, otherwise right--. while (1) &#123; //loop util right is prime while (1) &#123; if (isPrime(right)) &#123; break; &#125; else &#123; right--; &#125; &#125; left = x - right; if (!isPrime(left) || (right - left) % 2 != 0) &#123; right--; &#125; else &#123; break; &#125; &#125;&#125;int main() &#123; int x; cin &gt;&gt; x; int steps = 0; int left = 2, right = x - 1; while (1) &#123; getPrime(left, right, x); int diff = right - left; steps++; if (diff == 0 || diff == 2) &#123; break; &#125; else &#123; x = diff; right = x - 1; left = 2; &#125; &#125; cout &lt;&lt; steps; return 0;&#125; H","categories":[],"tags":[{"name":"UNSW","slug":"UNSW","permalink":"https://illuca.github.io/tags/UNSW/"}]},{"title":"朦生","slug":"朦生","date":"2023-02-19T12:09:45.000Z","updated":"2024-02-21T11:13:24.205Z","comments":true,"path":"2023/02/19/朦生/","link":"","permalink":"https://illuca.github.io/2023/02/19/%E6%9C%A6%E7%94%9F/","excerpt":"","text":"那刚刚还有的，现在就未必还在了 就像天空目送彩虹 记忆渐渐朦胧 失落一如杂草遍地丛生 昼夜宛如山峰 日月拥着星星 大人带着孩子 不知疲倦 他们的脚印丈量我的寿命 路线影响我的心情 平原啊是我的身躯 静静的躺着，躺到身体变冷，心脏停止跳动 那我又将另一种醒来 对，就像那昼夜交替 失落的弦还在演奏悠扬 零度的水在表演沸腾 终点藏在氤氲的答案中 清晰可见的 平静的地平线永恒不变","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://illuca.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"孩子","slug":"孩子","date":"2021-12-15T08:20:43.000Z","updated":"2024-02-21T11:13:58.371Z","comments":true,"path":"2021/12/15/孩子/","link":"","permalink":"https://illuca.github.io/2021/12/15/%E5%AD%A9%E5%AD%90/","excerpt":"","text":"我是回忆海边捡贝壳的孩子 我以为翻越高山走过荒漠 眼泪已经干涸 可一回首还是温暖的海风 冷了以为在严冬，热了以为在酷暑 渴了在荒漠，随波逐流又在攀爬高山 尝着略咸的海水，恍惚间尽了一世心酸 我是抱膝看海的孩子 一瓢水就将我淋个通透 没有人管我就一直哭 欣喜泪水聚成了海洋 热情融化了夕阳 不知风雨雷电，都还未曾光顾 也许永无那些灾难 也没什么星辰大海 我守着的，只有水波荡漾一碧湖","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://illuca.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}],"categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://illuca.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"https://illuca.github.io/tags/array/"},{"name":"simulation","slug":"simulation","permalink":"https://illuca.github.io/tags/simulation/"},{"name":"tree","slug":"tree","permalink":"https://illuca.github.io/tags/tree/"},{"name":"dfs","slug":"dfs","permalink":"https://illuca.github.io/tags/dfs/"},{"name":"prefix sum","slug":"prefix-sum","permalink":"https://illuca.github.io/tags/prefix-sum/"},{"name":"string","slug":"string","permalink":"https://illuca.github.io/tags/string/"},{"name":"two pointers","slug":"two-pointers","permalink":"https://illuca.github.io/tags/two-pointers/"},{"name":"medium","slug":"medium","permalink":"https://illuca.github.io/tags/medium/"},{"name":"DP","slug":"DP","permalink":"https://illuca.github.io/tags/DP/"},{"name":"memorization","slug":"memorization","permalink":"https://illuca.github.io/tags/memorization/"},{"name":"dp","slug":"dp","permalink":"https://illuca.github.io/tags/dp/"},{"name":"greedy","slug":"greedy","permalink":"https://illuca.github.io/tags/greedy/"},{"name":"backtrack","slug":"backtrack","permalink":"https://illuca.github.io/tags/backtrack/"},{"name":"linked list","slug":"linked-list","permalink":"https://illuca.github.io/tags/linked-list/"},{"name":"hash","slug":"hash","permalink":"https://illuca.github.io/tags/hash/"},{"name":"prefix","slug":"prefix","permalink":"https://illuca.github.io/tags/prefix/"},{"name":"stack","slug":"stack","permalink":"https://illuca.github.io/tags/stack/"},{"name":"heap","slug":"heap","permalink":"https://illuca.github.io/tags/heap/"},{"name":"sub","slug":"sub","permalink":"https://illuca.github.io/tags/sub/"},{"name":"easy","slug":"easy","permalink":"https://illuca.github.io/tags/easy/"},{"name":"grpah","slug":"grpah","permalink":"https://illuca.github.io/tags/grpah/"},{"name":"combination","slug":"combination","permalink":"https://illuca.github.io/tags/combination/"},{"name":"DFS","slug":"DFS","permalink":"https://illuca.github.io/tags/DFS/"},{"name":"graph","slug":"graph","permalink":"https://illuca.github.io/tags/graph/"},{"name":"topological sort","slug":"topological-sort","permalink":"https://illuca.github.io/tags/topological-sort/"},{"name":"BFS","slug":"BFS","permalink":"https://illuca.github.io/tags/BFS/"},{"name":"hard","slug":"hard","permalink":"https://illuca.github.io/tags/hard/"},{"name":"modify original data","slug":"modify-original-data","permalink":"https://illuca.github.io/tags/modify-original-data/"},{"name":"inorder","slug":"inorder","permalink":"https://illuca.github.io/tags/inorder/"},{"name":"BST","slug":"BST","permalink":"https://illuca.github.io/tags/BST/"},{"name":"space complexity","slug":"space-complexity","permalink":"https://illuca.github.io/tags/space-complexity/"},{"name":"matrix","slug":"matrix","permalink":"https://illuca.github.io/tags/matrix/"},{"name":"divide and conquer","slug":"divide-and-conquer","permalink":"https://illuca.github.io/tags/divide-and-conquer/"},{"name":"pattern match","slug":"pattern-match","permalink":"https://illuca.github.io/tags/pattern-match/"},{"name":"hankerrank","slug":"hankerrank","permalink":"https://illuca.github.io/tags/hankerrank/"},{"name":"UNSW","slug":"UNSW","permalink":"https://illuca.github.io/tags/UNSW/"},{"name":"notes","slug":"notes","permalink":"https://illuca.github.io/tags/notes/"},{"name":"algorithm","slug":"algorithm","permalink":"https://illuca.github.io/tags/algorithm/"},{"name":"PAT","slug":"PAT","permalink":"https://illuca.github.io/tags/PAT/"},{"name":"LCM","slug":"LCM","permalink":"https://illuca.github.io/tags/LCM/"},{"name":"segment tree","slug":"segment-tree","permalink":"https://illuca.github.io/tags/segment-tree/"},{"name":"LCA","slug":"LCA","permalink":"https://illuca.github.io/tags/LCA/"},{"name":"recursion","slug":"recursion","permalink":"https://illuca.github.io/tags/recursion/"},{"name":"tarjan","slug":"tarjan","permalink":"https://illuca.github.io/tags/tarjan/"},{"name":"union find","slug":"union-find","permalink":"https://illuca.github.io/tags/union-find/"},{"name":"binary-search","slug":"binary-search","permalink":"https://illuca.github.io/tags/binary-search/"},{"name":"KMP","slug":"KMP","permalink":"https://illuca.github.io/tags/KMP/"},{"name":"leetcode binary-search","slug":"leetcode-binary-search","permalink":"https://illuca.github.io/tags/leetcode-binary-search/"},{"name":"随笔","slug":"随笔","permalink":"https://illuca.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}