{"meta":{"title":"兰陵","subtitle":"","description":"illuca的个人博客","author":"illuca","url":"https://illuca.github.io","root":"/"},"pages":[{"title":"categories","date":"2021-09-02T16:38:28.000Z","updated":"2023-05-12T13:59:08.921Z","comments":true,"path":"categories/index.html","permalink":"https://illuca.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2021-09-02T16:22:00.000Z","updated":"2023-05-12T13:59:08.921Z","comments":true,"path":"about/index.html","permalink":"https://illuca.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-09-02T16:38:35.000Z","updated":"2023-05-12T13:59:08.921Z","comments":true,"path":"tags/index.html","permalink":"https://illuca.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"COMP9315 DBMS Implementation","slug":"COMP9315","date":"2023-05-12T16:00:00.000Z","updated":"2023-05-13T09:16:36.041Z","comments":true,"path":"2023/05/13/COMP9315/","link":"","permalink":"https://illuca.github.io/2023/05/13/COMP9315/","excerpt":"","text":"Since i have no course to choose, so i have to choose this one. On the other hand, this course can help me to understand better about database. Although this course is called Database Implementation, it does not teach you how to write a database application. Instead, the course is full of various algorithms, taking Postgre as example. The quiz almost does not change every year. It aims to help you check whether you grasp the knowledge taught on lectures. Assessment 1For assessment 1, it needs you to implement a new type called gcoord. You can get more details on https://cgi.cse.unsw.edu.au/~cs9315/23T1/assignment/1/index.php. Note 1: Because C Postgre library has special processing on struct storage. You should follow the document standard. 12345678typedef struct GeoCoord&#123; double latitude_value; double longitude_value; char latitude_direction; char longitude_direction; char location_name[FLEXIBLE_ARRAY_MEMBER];&#125; GeoCoord; As shown above, variable-length variable must be declared at the end of the struct. You can get more details on https://www.postgresql.org/docs/current/xfunc-c.html. Even though you don’t pay attention to this special usage, malloc can also helps you pass lots of tests provided by the convener. Note 2: This problem is about precision. For function Convert2DMS: 1234It converts the greographical coordinates from decimal to DMS(degree, minute, second). The calculation can be described as:D = floor(Ddec),M = floor(60 × |Ddec-D|),S = floor(3600 × |Ddec-D| - 60 × M), Because latitude_value in my struct is double and double will cause precision loss when executing operation like: 123456int main() &#123; double x = 73.55; int result = (int)((x - 73) * 60); printf(&quot;result: %d&quot;, result); // result: 32 return 0;&#125; The result should be 33 but program gives us 32. Since the coordinate value do not have more than 4 decimal places, so we can solve it as shown below: 123456789101112131415161718192021222324double myround(double x) &#123; double result = (x-round(x)); if (fabs(result) &lt; 0.0001) &#123; return round(x); &#125; else &#123; return x; &#125;&#125;void DMS(char *string, double value, char direction) &#123; int d_dec, degree, minute, second; double diff; degree = (int) floor(value); diff = (value - degree); minute = (int) floor(myround(60*diff)); second = (int) floor(myround(3600*diff - 60 * minute)); if (minute == 0) &#123; sprintf(string, &quot;%d°%c&quot;, degree, direction); &#125; else if (second == 0) &#123; sprintf(string, &quot;%d°%d&#x27;%c&quot;, degree, minute, direction); &#125; else &#123; sprintf(string, &quot;%d°%d&#x27;%d\\&quot;%c&quot;, degree, minute, second, direction); &#125;&#125; But my friend has better idea: 123456typedef struct GeoCoord &#123; int latitude; int longitude;&#125;latitude = (int)((x * 10000) + 0.5);longitude = (int)((y * 10000) + 0.5); Note 3: Because latitude and longitude in my struct are double and double is 64 bit. So we need 64-bit hash. 1234567891011121314151617181920212223242526static uint32_thash_uint64(uint64_t key)&#123; key = (~key) + (key &lt;&lt; 21); key = key ^ (key &gt;&gt; 24); key = key + (key &lt;&lt; 3) + (key &lt;&lt; 8); key = key ^ (key &gt;&gt; 14); key = key + (key &lt;&lt; 2) + (key &lt;&lt; 4); key = key ^ (key &gt;&gt; 28); key = key + (key &lt;&lt; 31); return (uint32_t)key;&#125;PG_FUNCTION_INFO_V1(gcoord_hash);Datumgcoord_hash(PG_FUNCTION_ARGS)&#123; GeoCoord* coord = (GeoCoord*)PG_GETARG_POINTER(0); uint32_t hash = 0; hash ^= (uint32_t) strlen(coord-&gt;location_name); hash ^= hash_uint64(coord-&gt;latitude_value); hash ^= hash_uint64(coord-&gt;longitude_value); hash ^= (uint32_t) coord-&gt;latitude_direction; PG_RETURN_UINT32(hash);&#125; I think it is too tricky and there should be a better solution. Assessment 2The second ass needs you to implement operation Sel and Join. You can find more details on https://cgi.cse.unsw.edu.au/~cs9315/23T1/assignment/2/. Note1: read page from file You need to read page from file and for each page, you read tuple from it. 1234567891011121314for (int page_idx = 0; page_idx &lt; total_page; page_idx++) &#123; buffer* buffer_p = request_page(t, page_idx); for (int tid = 0; tid &lt; get_tuples_num(buffer_p); tid++) &#123; Tuple tuple = get_tuple_by_tuple_id(buffer_p, tid); if (tuple[idx] == cond_val) &#123; result-&gt;tuples[counter++] = tuple; &#125; else &#123; free(tuple); &#125; &#125; release_page(buffer_p); log_release_page(buffer_p-&gt;page_id);&#125; The thought seems simple but i didn’t come out at the beginning. I read all pages from files and then read tuples from pages. Note2: buffer pool Note3: file pool Conclusion","categories":[],"tags":[{"name":"unsw","slug":"unsw","permalink":"https://illuca.github.io/tags/unsw/"}]},{"title":"上海鼎策","slug":"9.2_上海鼎策","date":"2021-09-01T16:00:00.000Z","updated":"2023-05-12T13:59:08.920Z","comments":true,"path":"2021/09/02/9.2_上海鼎策/","link":"","permalink":"https://illuca.github.io/2021/09/02/9.2_%E4%B8%8A%E6%B5%B7%E9%BC%8E%E7%AD%96/","excerpt":"","text":"银行贷款，分期归还12345678910public List&lt;Double&gt; getRepayment(Double allMoney,int numberOfMonths) &#123; Double money = allMoney / numberOfMonths; List&lt;Double&gt; res = new ArrayList&lt;&gt;(); for(int i=0;i&lt;numberOMonths-1;i++) &#123; res.add(money); &#125; Double lastMonthMoney = allMoney - (numberOfMonths-1)*money; res.add(lastMonthMoney); return res;&#125; 考虑小数问题 归笼与未归笼如果0&lt;count&lt;total，就是部分归笼，count=0就是未归笼，count=total就是归笼。要求编写sql语句达成如下效果： 原表： 经过查询输出： 12345678910111213141516171819create database ShangHaiDingCe;use ShangHaiDingCe;drop table if exists sheep;create table sheep ( id int not null primary key auto_increment, total int, number int);insert into sheep (id, total, number) values (null,10,4);insert into sheep (id, total, number) values (null,10,10);insert into sheep (id, total, number) values (null,10,0);insert into sheep (id, total, number) values (null,10,8);insert into sheep (id, total, number) values (null,10,7);insert into sheep (id, total, number) values (null,10,0);select * from sheep; 12345678select id,total,number, case when number=0 then &#x27;未归笼&#x27; when number=total then &#x27;归笼&#x27; else &#x27;部分归笼&#x27; end as &#x27;STATUS&#x27;from sheep; linux解压命令 tar -zxv -f apache-tomcat-8.0.29.tar.gz 部署tomcat服务器方法一： 解压tomcat tar -zxv -f apache-tomcat-8.0.29.tar.gz 进入tomcat目录 开放端口8080 启动tomcat ./tomcat/bin/start.sh 可以通过ip:8080访问tomcat主页 war包通过xftp上传到webapps下 可以通过ip:8080/war包名称访问项目 方法二： 解压tomcat 开放端口 将tomcat配置为系统服务 1234567891011121314151617#创建Tomcat8服务文件$ vi /usr/lib/systemd/system/tomcat8.service#tomcat8.service文件内容：[Unit]Description=Tomcat8After=syslog.target network.target remote-fs.target nss-lookup.target[Service]Type=forkingExecStart=/usr/tomcat/tomcat8/bin/startup.shExecReload=/usr/tomcat/tomcat8/bin/startup.shExecStop=/usr/tomcat/tomcat8/bin/shutdown.sh[Install]WantedBy=multi-user.target 12345#设置Tomcat8开机启动$ systemctl enable tomcat8#启动tomcat8服务$ systemctl start tomcat8 实时查看tomcat日志","categories":[],"tags":[]},{"title":"杭开环境","slug":"9.1_杭开环境","date":"2021-08-31T16:00:00.000Z","updated":"2023-05-12T13:59:08.920Z","comments":true,"path":"2021/09/01/9.1_杭开环境/","link":"","permalink":"https://illuca.github.io/2021/09/01/9.1_%E6%9D%AD%E5%BC%80%E7%8E%AF%E5%A2%83/","excerpt":"","text":"mybatis 动态sql123456&lt;select id=&quot;findActiveBlogWithTitleLike&quot; parameterType=&quot;Blog&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test=&quot;title != null and title != &#x27;&#x27;&quot;&gt; AND title like #&#123;title&#125; &lt;/if&gt;&lt;/select&gt; mybatis xml有哪些标签 &lt;select&gt; delete update 动态SQL choose if when otherwise set 两个用户同时下订单redis取出自定义对象直接转换redis在现实中的应用购物车","categories":[],"tags":[]},{"title":"鹏信科技","slug":"8.31_鹏信科技","date":"2021-08-30T16:00:00.000Z","updated":"2023-05-12T13:59:08.920Z","comments":true,"path":"2021/08/31/8.31_鹏信科技/","link":"","permalink":"https://illuca.github.io/2021/08/31/8.31_%E9%B9%8F%E4%BF%A1%E7%A7%91%E6%8A%80/","excerpt":"","text":"村民 干部今天的面试题:村里新来一位干部，5位村民分别听到关于这位干部的如下情况： (1)姓莫，中年，女干部，精通会计; (2)姓徐，中年，男干部，懂建筑设计; (3)姓刘，青年，男干部，熟悉农业生产技术; (4)姓吕，青年，男干部，懂建筑设计; (5)姓莫，老年，男干部，熟悉农业生产技术。 每位村民听到的四项情况中各只有一项正确。这位新来的干部是 123456789假设精通农业，则不姓刘、莫，不为青、老，不为男， 则姓徐、吕，为中，为女 则为徐中女、吕中女，则(1)命中2个条件，不符合 假设精通建筑，则不姓徐、吕，不为中、青，不为男， 则姓刘、莫，为老，为女 则为刘老女、莫老女， 莫老女时，(5)命中2个条件，不符合 刘老女时，符合 计算字符出现的次数，字符之间用分号间隔例如HelloWorld，输出H-1;e-1;l-3;o-2;d-1 12345678910111213141516171819202122232425public class Main &#123; public static void countAndPrint(String input) &#123; Map&lt;Character, Integer&gt; map = new LinkedHashMap&lt;&gt;(); List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 计数 for (int i = 0; i &lt; input.length(); i++) &#123; Character ch = input.charAt(i); if (!map.containsKey(ch)) &#123; map.put(ch, 1); &#125; else &#123; map.put(ch, map.get(ch) + 1); &#125; &#125; // 遍历map并添加到list中 for (Map.Entry&lt;Character, Integer&gt; entry : map.entrySet()) &#123; list.add(entry.getKey() + &quot;-&quot; + entry.getValue()); &#125; String res = StringUtils.join(list, &quot;;&quot;); System.out.println(res); &#125; public static void main(String[] args) &#123; countAndPrint(&quot;HelloWorld&quot;); &#125;&#125; 因为要顺序的输出，所以用到LinkedHashMap 方法二： 1234567891011121314151617181920212223private static void countAndPrint2(String input) &#123; int len = (int) &#x27;z&#x27;; // 默认初始化为0 int[] num = new int[len]; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; input.length(); i++) &#123; char ch = input.charAt(i); num[ch] += 1; &#125; for (int i = 0; i &lt; input.length(); i++) &#123; char ch = input.charAt(i); if (!set.contains(ch)) &#123; list.add(ch + &quot;-&quot; + num[ch]); &#125; set.add(ch); &#125; String res = StringUtils.join(list, &quot;;&quot;); System.out.println(res); &#125; redis的数据类型List、Hash、Set 123456789# 创建并初始化$ LPUSH list1 5 6 7 8 9# 输出$ LRANGE list1 0 -198765 listlist是一个栈，操作是lpush、rpush、lpop、rpop \u0010lpush表示list push、lrange表示list range 字符串1234$ set username naruto$ get usernamenaruto hmset 表示hash multiple set可以一次插入多个键值对 1234# 创建并初始化$ hmset student01 name &quot;naruto&quot; age 18# 获取键值$ hget student01 name hset 表示hash set与hmset相比，一次只能插入一个键值对 12345# 创建并初始化$ hset student01 name &quot;naruto&quot;$ hset student02 age 18# 获取键值$ hget student01 name set 表示无序集合12345678910127.0.0.1:6379&gt; sadd student_name naruto(integer) 1127.0.0.1:6379&gt; sadd student_name &quot;sasuke&quot;(integer) 1127.0.0.1:6379&gt; sadd student_name sakura(integer) 1127.0.0.1:6379&gt; smembers student_name1) &quot;sakura&quot;2) &quot;naruto&quot;3) &quot;sasuke&quot; 可以看到并没有按照我们添加的顺序进行打印，所以是无序集合 zset 表示有序集合123456789101112131415161718192021222324127.0.0.1:6379&gt; zadd roles 1 大蛇(integer) 1127.0.0.1:6379&gt; zadd roles 2 八神奄(integer) 1127.0.0.1:6379&gt; zadd roles 2 隆(integer) 1127.0.0.1:6379&gt; zadd roles 3 草薙京(integer) 1127.0.0.1:6379&gt; zrange roles 0 10大蛇八神奄隆草薙京127.0.0.1:6379&gt; zrange roles 0 10 withscores大蛇1八神奄2隆2草薙京3 hashmap的属性1234567891011int threshold;// 存放键值对transient Node&lt;K,V&gt;[] table;The number of key-value mappings contained in this map.transient int size;// 是缓存// Holds cached entrySet(). Note that AbstractMap fields are used for keySet() and values().transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; threshold阈值 threshold表示当HashMap的size大于threshold时会执行resize操作。threshold=capacity*loadFactor hashmap的方法isEmpty() containsKey()，containsValue() entrySet() put() putAll() remove() keys()，values() clear() get() hashmap用到的设计模式Nodes 组合模式、代理模式 composite1234567891011121314151617181920212223242526272829303132333435363738package com.lin.composite;public abstract class OrganizationComponmet &#123; private String name; private String des; protected void add(OrganizationComponmet organizationComponmet) &#123; throw new UnsupportedOperationException(); &#125; protected void remove(OrganizationComponmet organizationComponmet) &#123; throw new UnsupportedOperationException(); &#125; public OrganizationComponmet(String name, String des) &#123; super(); this.name = name; this.des = des; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getDes() &#123; return des; &#125; public void setDes(String des) &#123; this.des = des; &#125; protected abstract void print(); &#125; University12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.lin.composite;import java.util.ArrayList;import java.util.List;public class University extends OrganizationComponmet&#123; List&lt;OrganizationComponmet&gt; organizationComponmets = new ArrayList&lt;OrganizationComponmet&gt;(); public University(String name, String des) &#123; super(name, des); &#125; @Override protected void add(OrganizationComponmet organizationComponmet) &#123; organizationComponmets.add(organizationComponmet); &#125; @Override protected void remove(OrganizationComponmet organizationComponmet) &#123; organizationComponmets.remove(organizationComponmet); &#125; @Override public String getDes() &#123; return super.getDes(); &#125; @Override public String getName() &#123; return super.getName(); &#125; @Override protected void print() &#123; System.out.println(&quot;---------------------&quot; + getName() + &quot;--------------------&quot;); for (OrganizationComponmet organizationComponmet : organizationComponmets) &#123; organizationComponmet.print(); &#125; &#125; &#125; College123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.lin.composite;import java.util.ArrayList;import java.util.List;public class College extends OrganizationComponmet&#123;List&lt;OrganizationComponmet&gt; organizationComponmets = new ArrayList&lt;OrganizationComponmet&gt;(); public College(String name, String des) &#123; super(name, des); &#125; @Override protected void add(OrganizationComponmet organizationComponmet) &#123; organizationComponmets.add(organizationComponmet); &#125; @Override protected void remove(OrganizationComponmet organizationComponmet) &#123; organizationComponmets.remove(organizationComponmet); &#125; @Override public String getDes() &#123; return super.getDes(); &#125; @Override public String getName() &#123; return super.getName(); &#125; @Override protected void print() &#123; System.out.println(&quot;---------------------&quot; + getName() + &quot;--------------------&quot;); for (OrganizationComponmet organizationComponmet : organizationComponmets) &#123; organizationComponmet.print(); &#125; &#125; &#125; Department1234567891011121314151617181920212223package com.lin.composite;public class Department extends OrganizationComponmet&#123; public Department(String name, String des) &#123; super(name, des); &#125; @Override public String getDes() &#123; return super.getDes(); &#125; @Override public String getName() &#123; return super.getName(); &#125; @Override protected void print() &#123; System.out.println(getName()); &#125; &#125; Client1234567891011121314151617181920212223242526272829package com.lin.composite;public class Client &#123; public static void main(String[] args) &#123; OrganizationComponmet university = new University(&quot;波大&quot;, &quot;美国大学&quot;); OrganizationComponmet college1 = new College(&quot;计算机学院&quot;, &quot;计算机&quot;); OrganizationComponmet college2 = new College(&quot;中文学院&quot;, &quot;中文&quot;); university.add(college1); university.add(college2); OrganizationComponmet department1 = new Department(&quot;软件工程专业&quot;, &quot;软件&quot;); OrganizationComponmet department2 = new Department(&quot;大数据专业&quot;, &quot;大数据&quot;); OrganizationComponmet department3 = new Department(&quot;汉语言专业&quot;, &quot;汉语言&quot;); OrganizationComponmet department4 = new Department(&quot;中华文化专业&quot;, &quot;中华文化&quot;); college1.add(department1); college1.add(department2); college2.add(department3); college2.add(department4); university.print(); System.out.println(&quot;--------------------------------------------&quot;); college1.print(); &#125;&#125; 分析 Map的put、putall交给AbstractHashMap实现，再交给HashMap实现，而结点的管理交给Node来实现。 什么是组合模式？大部分国家的军队都采用层次结构管理。 每支部队包括几个师， 师由旅构成， 旅由团构成， 团可以继续划分为排。 最后， 每个排由一小队实实在在的士兵组成。 军事命令由最高层下达， 通过每个层级传递， 直到每位士兵都知道自己应该服从的命令。 组件 （Component） 接口描述了树中简单项目和复杂项目所共有的操作。 叶节点 （Leaf） 是树的基本结构， 它不包含子项目。 一般情况下， 叶节点最终会完成大部分的实际工作， 因为它们无法将工作指派给其他部分。 容器 （Container）——又名 “组合 （Composite）”——是包含叶节点或其他容器等子项目的单位。 容器不知道其子项目所属的具体类， 它只通过通用的组件接口与其子项目交互。 容器接收到请求后会将工作分配给自己的子项目， 处理中间结果， 然后将最终结果返回给客户端。 客户端 （Client） 通过组件接口与所有项目交互。 因此， 客户端能以相同方式与树状结构中的简单或复杂项目交互。 而Map也是一样，先让AbstractHashMap完成一些事情，再将剩下的任务交给HashMap完成，HashMap又将一部分任务交给Node完成，Node是容器。 ${}和#{}的区别#{}是预编译，${}是字符串替换 mybatis有什么好处 sql参数注入、返回 动态sql mybatis注入支持的数据类型基本数据类型：整型、浮点、字符串 复杂数据类型：Map、引用 java sql String varchar Integer Integer BigDecimal numeric date date calendar timestamp byte[] blob Double double 12345678910// 这里parameterType是Map&lt;sql id=&quot;Base_Column_List&quot; &gt; id, car_dept_name, car_maker_name, icon,car_maker_py,hot_type &lt;/sql&gt; &lt;select id=&quot;selectByPrimaryKey&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.lang.Long&quot; &gt; select &lt;include refid=&quot;Base_Column_List&quot; /&gt; from common_car_make where id = #&#123;id,jdbcType=BIGINT&#125; &lt;/select&gt; 123456789101112// parameterType是自定义引用类型&lt;update id=&quot;updateByPrimaryKeySelective&quot; parameterType=&quot;com.illuca.entity.Student&quot; &gt; update student &lt;set &gt; &lt;if test=&quot;studentName != null&quot; &gt; student_name = #&#123;studentName,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=&quot;score != null&quot; &gt; score = #&#123;score,jdbcType=VARCHAR&#125; &lt;/set&gt; where student_id = #&#123;studentId,jdbcType=BIGINT&#125; &lt;/update&gt; 删除A中存在但B中不存在的记录delete from A where tagetColumn not in ( select targetColumn from B) 网关解决什么问题？什么是熔断？解决路由问题","categories":[],"tags":[]},{"title":"同余科技","slug":"8.30_面试上海同余科技","date":"2021-08-29T16:00:00.000Z","updated":"2023-05-12T13:59:08.920Z","comments":true,"path":"2021/08/30/8.30_面试上海同余科技/","link":"","permalink":"https://illuca.github.io/2021/08/30/8.30_%E9%9D%A2%E8%AF%95%E4%B8%8A%E6%B5%B7%E5%90%8C%E4%BD%99%E7%A7%91%E6%8A%80/","excerpt":"","text":"多线程在项目中有运用么？后端单元测试包，生成假数据Mock 123456789@Autowiredprivate WebApplicationContext webApplicationContext;private MockMvc mockMvc;//在每个测试方法执行之前都初始化MockMvc对象@BeforeEachpublic void setupMockMvc() &#123; mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();&#125; 1234567891011121314@DisplayName(&quot;测试根据Id获取User&quot;)@Testvoid contextLoads() throws Exception &#123; //perform,执行一个RequestBuilders请求，会自动执行SpringMVC的流程并映射到相应的控制器执行处理 mockMvc.perform(MockMvcRequestBuilders //构造一个get请求 .get(&quot;/user/1&quot;) //请求类型 json .contentType(MediaType.APPLICATION_JSON)) // 期待返回的状态码是4XX，因为我们并没有写/user/&#123;id&#125;的get接口 .andExpect(MockMvcResultMatchers.status().is4xxClientError());&#125; jwt在项目中应用生成token TOKEN分为3个部分=头部 负载 签证 头部声明jwt和所用算法 负载包含用户信息 用加密算法生成signature nacos作用负载均衡 注册中心 redis项目中应用单点登录","categories":[],"tags":[]},{"title":"微萌医院管理","slug":"8.27_微萌","date":"2021-08-26T16:00:00.000Z","updated":"2023-05-12T13:59:08.920Z","comments":true,"path":"2021/08/27/8.27_微萌/","link":"","permalink":"https://illuca.github.io/2021/08/27/8.27_%E5%BE%AE%E8%90%8C/","excerpt":"","text":"静态代理描述：通过代理去访问目标对象，代理可以对目标对象的功能进行扩充。 接口类 12345package com.proxy;public interface IUserDao &#123; public void save();&#125; 目标对象UserDao 123456789package com.proxy;public class UserDao implements IUserDao&#123; @Override public void save() &#123; System.out.println(&quot;保存数据&quot;); &#125;&#125; 代理 12345678910111213141516package com.proxy;public class UserDaoProxy implements IUserDao&#123; private IUserDao target; public UserDaoProxy(IUserDao target) &#123; this.target = target; &#125; @Override public void save() &#123; System.out.println(&quot;开启事务&quot;);//扩展了额外功能 target.save(); System.out.println(&quot;提交事务&quot;); &#125;&#125; 测试类 1234567891011121314package com.proxy;import org.junit.Test;public class StaticUserProxy &#123; @Test public void testStaticProxy()&#123; //目标对象 IUserDao target = new UserDao(); //代理对象 IUserDao proxy = new UserDaoProxy(target); proxy.save(); &#125;&#125; 动态代理接口类 12345package com.proxy;public interface IUserDao &#123; public void save();&#125; 目标对象 123456789package com.proxy;public class UserDao implements IUserDao&#123; @Override public void save() &#123; System.out.println(&quot;保存数据&quot;); &#125;&#125; 动态代理对象 1234567891011121314151617181920212223242526272829303132package com.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ProxyFactory &#123; private Object target;// 维护一个目标对象 public ProxyFactory(Object target) &#123; this.target = target; &#125; // 为目标对象生成代理对象 public Object getProxyInstance() &#123; return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;开启事务&quot;); // 执行目标对象方法 Object returnValue = method.invoke(target, args); System.out.println(&quot;提交事务&quot;); return null; &#125; &#125;); &#125;&#125; 测试类 123456789101112131415package com.proxy;import org.junit.Test;public class TestProxy &#123; @Test public void testDynamicProxy ()&#123; IUserDao target = new UserDao(); System.out.println(target.getClass()); //输出目标对象信息 IUserDao proxy = (IUserDao) new ProxyFactory(target).getProxyInstance(); System.out.println(proxy.getClass()); //输出代理对象信息 proxy.save(); //执行代理方法 &#125;&#125; xml装载 缓存 代理 mapper 开启 获取相关xml东西 vue静态路由动态路由vue如何实现页面不刷新如何自己写一个组件slot 父组件如何传值给子组件ref :data mvc的执行流程AOP切面class 疯狂问代理各种代理% linux启动服务Centos7 自启动方式 一 通过（init.d）服务的方式自启动 1.在/etc/init.d 下建立相关程序的启动脚本 ln -s /etc/init.d/服务名 /etc/rc.d/rc3.d/S100服务名 //S:开机自启动 100:启动顺序 2.chkconfig –add 服务名 3.chkconfig 服务名 on 开机自启动 chkconfig 服务名 off 关闭自启动 4.service 服务名 start 手动启动服务 5.service 服务名 stop 手动关闭服务 二 通过systemctl 服务的方式自启动 1.cd /usr/lib/systemd/system/ 2.vi 服务名.service # Systemd unit file for default tomcat # # To create clones of this service: # DO NOTHING, use tomcat@.service instead. redis锁序列化的多种实现方式实现serializable接口实现Serializable并且要有serialVersionUID，序列化UID 实现Externalizable接口Externalizable接口继承了Serializable接口 1234public interface Externalizable extends java.io.Serializable &#123; /** * The object implements the writeExternal method to save its contents * by calling the methods of DataOutput for its primitive values or 并且多了两个方法writeExternal和readExternal 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Dataclass Person implements Externalizable&#123; private static final long serialVersionUID = 1L;&lt;br&gt; String userName; String password; String age; public Person(String userName, String password, String age) &#123; super(); this.userName = userName; this.password = password; this.age = age; &#125; public Person() &#123; super(); &#125; /** * 序列化操作的扩展类 */ @Override public void writeExternal(ObjectOutput out) throws IOException &#123; //增加一个新的对象 Date date=new Date(); out.writeObject(userName); out.writeObject(password); out.writeObject(date); &#125; /** * 反序列化的扩展类 */ @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; //注意这里的接受顺序是有限制的哦，否则的话会出错的 // 例如上面先write的是A对象的话，那么下面先接受的也一定是A对象... userName=(String) in.readObject(); password=(String) in.readObject(); SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date=(Date)in.readObject(); System.out.println(&quot;反序列化后的日期为:&quot;+sdf.format(date)); &#125; @Override public String toString() &#123; //注意这里的年龄是不会被序列化的，所以在反序列化的时候是读取不到数据的 return &quot;用户名:&quot;+userName+&quot;密 码:&quot;+password+&quot;年龄:&quot;+age; &#125;&#125; synchronized和Lock的选择通过Lock可以通过tryLock获得返回值知道线程是否成功获得了锁，而synchronized不行。 synchronize是JVM层面的，线程异常时JVM会让线程放弃锁，而Lock是JDK层面的，需要手动Lock.unlock()","categories":[],"tags":[]},{"title":"思锐科技","slug":"8.27_思锐科技","date":"2021-08-26T16:00:00.000Z","updated":"2023-05-12T13:59:08.920Z","comments":true,"path":"2021/08/27/8.27_思锐科技/","link":"","permalink":"https://illuca.github.io/2021/08/27/8.27_%E6%80%9D%E9%94%90%E7%A7%91%E6%8A%80/","excerpt":"","text":"字段是日期，当时最后要求查出来是月份，月度金额核心：date_format(date,%m)、month(date) 123456789101112131415161718drop table if exists Salary;create table Salary ( id int not null auto_increment primary key, date datetime not null, profit double not null);insert into Salary (id, date, profit) VALUES (null,&#x27;2018-03-04&#x27;,100);insert into Salary (id, date, profit) VALUES (null,&#x27;2018-03-05&#x27;,200);insert into Salary (id, date, profit) VALUES (null,&#x27;2018-04-04&#x27;,300);insert into Salary (id, date, profit) VALUES (null,&#x27;2018-04-04&#x27;,300);insert into Salary (id, date, profit) VALUES (null,&#x27;2018-06-04&#x27;,200);insert into Salary (id, date, profit) VALUES (null,&#x27;2018-07-04&#x27;,200);select * from Salary;# 月利润select DATE_FORMAT(date,&#x27;%m&#x27;), sum(Salary.profit) from si_rui.Salary group by DATE_FORMAT(date,&#x27;%m&#x27;) ; 12# 月利润select MONTH(date) as &#x27;月度&#x27;, sum(Salary.profit) as &#x27;月利润&#x27; from si_rui.Salary group by MONTH(date); 12# 年利润select DATE_FORMAT(date,&#x27;%Y&#x27;) as &#x27;月度&#x27;, sum(Salary.profit) as &#x27;月利润&#x27; from si_rui.Salary group by DATE_FORMAT(date,&#x27;%Y&#x27;) ; js中checkbox如何设置取消12var check = document.getElementsByTagName(&#x27;input&#x27;)[0];check = false; sql包含三的like匹配整个单元格，regexp匹配单元格的值 举例：名字中带’三’的 select * from jwt_test.user where username like &#39;%三%&#39;; select * from jwt_test.user where username regexp &#39;三&#39; 举例：名字带’三’或’四’的 select * from user where username regexp &#39;三|四&#39; spring的包Beans context 提供IOC expression jdbc orm test tx事务 webmvc websocket通信 springmvc是控制器单例的，有什么问题，如何解决默认是单例的。 12345678910111213@Controller@RequestMapping(&quot;/demo&quot;)public class MultViewController &#123; private static int st = 0; //静态的 private int index = 0; //非静态 @RequestMapping(&quot;/test&quot;) public void test() &#123; System.out.println(st++ + &quot; | &quot; + index++); &#125;&#125; 当多个请求即多个线程访问时，出现资源重复增加，而我们想要的不是这样，每个请求访问Controller应该有独立的属性。 123456左静态 右非静态0 | 01 | 12 | 23 | 34 | 4 改为多例模式 controller增加注解: 1@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE) 输出结果如下，可见静态资源不管是单例还是多例，表现都一致，而非静态不一致。 123456左静态 右非静态0 | 01 | 02 | 03 | 04 | 0 解决方案是： 不要再controller中定义成员变量 定义非静态成员变量时，通过@Scope(prototype)设置为多例模式 单表1000万的数据量的经历ajax是什么，异步和同步有什么区别a中有3个开关，b中有3个灯，互相看不见100个自然数，99个放入数组arr，找出没有放入的那个运行时异常和一般异常有什么区别，spring的事务怎么处理如何知道一串中英文字符串的字节数12345public static void main(String[] args) &#123; String string = &quot;我有一个梦想i have a dream&quot;; byte[] bytes = string.getBytes(); System.out.println(&quot;bytes.length = &quot; + bytes.length);&#125; utf-8编码中，一个英文字符占用一个字节，一个汉字占用3~4个字节。 sql语句如何去重在表中，可能会包含重复值。这并不成问题，不过，有时您也许希望仅仅列出不同（distinct）的值。 关键词 DISTINCT 用于返回唯一不同的值。 简单举例：select distinct(Salary) from Employee; 复杂举例：选出第二高的成绩 123select(select distinct(`Salary`) from Employee order by Salary desc limit 1,1)as SecondHighestSalary; distinct是去重的意思 list如何去重123456789101112131415161718192021222324@Test public void removeDuplicateUser() &#123; // 2个同名的人 User user1 = new User(&quot;张三&quot;, &quot;123&quot;); User user2 = new User(&quot;张三&quot;, &quot;888&quot;); User user3 = new User(&quot;李四&quot;, &quot;789&quot;); List&lt;User&gt; userList = new ArrayList&lt;&gt;(); userList.add(user1); userList.add(user2); userList.add(user3); System.out.println(&quot;去重前&quot;); System.out.println(userList); HashSet&lt;String&gt; hashSet = new HashSet&lt;&gt;(); List&lt;User&gt; unique = userList.stream() .filter(e -&gt; &#123; // 如果已经存在 返回false // filter接收一个断言 return hashSet.add(e.getUsername()); &#125;) .collect(Collectors.toList()); System.out.println(&quot;去重后&quot;); System.out.println(unique); &#125; 索引问题 外键是否建立了索引如何防止sql注入如果两个线程同时对某个文件写入会发生什么？vue手动实现v-model","categories":[],"tags":[]},{"title":"网新恒天","slug":"8.27_网新恒天-美国道富","date":"2021-08-26T16:00:00.000Z","updated":"2023-05-12T13:59:08.920Z","comments":true,"path":"2021/08/27/8.27_网新恒天-美国道富/","link":"","permalink":"https://illuca.github.io/2021/08/27/8.27_%E7%BD%91%E6%96%B0%E6%81%92%E5%A4%A9-%E7%BE%8E%E5%9B%BD%E9%81%93%E5%AF%8C/","excerpt":"","text":"抽象类和接口的区别 java什么时候会有内存泄漏？ 数据库的加快查询的方法？索引 分表 索引和主键有什么区别？","categories":[],"tags":[]},{"title":"五色云科技","slug":"8.26_五色云网络科技","date":"2021-08-25T16:00:00.000Z","updated":"2023-05-12T13:59:08.920Z","comments":true,"path":"2021/08/26/8.26_五色云网络科技/","link":"","permalink":"https://illuca.github.io/2021/08/26/8.26_%E4%BA%94%E8%89%B2%E4%BA%91%E7%BD%91%E7%BB%9C%E7%A7%91%E6%8A%80/","excerpt":"","text":"文件操作1)生成一个文件file1,每一行随机生成5个数字,数字之间用逗号隔开 2)读取文件fle1,计算并输出每一行数字的总和 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import com.sun.deploy.util.StringUtils;import java.io.*;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.Random;public class Demo1 &#123; private static final String name = &quot;file1&quot;; public static void writeNumbers() throws IOException &#123; FileWriter writer = new FileWriter(&quot;file1&quot;); Random random = new Random(); // 输入5行 for (int i = 0; i &lt; 5; i++) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 输入5个数字 for (int j = 0; j &lt; 5; j++) &#123; list.add(String.valueOf(random.nextInt())); &#125; String line = StringUtils.join(list, &quot;,&quot;); writer.write(line + &quot;\\n&quot;); &#125; writer.close(); &#125; public static void readNumbers() throws IOException &#123; // 创建流 FileReader reader = new FileReader(&quot;file1&quot;); BufferedReader bufferedReader = new BufferedReader(reader); // 数字list List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); // 读取 按行 String line; while ((line = bufferedReader.readLine()) != null) &#123; String[] split = line.split(&quot;,&quot;); List&lt;String&gt; asList = Arrays.asList(split); System.out.println(asList.stream().map(elem -&gt; &#123; return Integer.valueOf(elem); &#125;).reduce(0, (a, b) -&gt; &#123; return a + b; &#125;)); &#125; // 关闭流 bufferedReader.close(); reader.close(); &#125; public static void main(String[] args) throws IOException &#123; writeNumbers(); System.out.println(&quot;打印和&quot;); readNumbers(); &#125;&#125; 字符串查找函数实现输入两个字符串A、B,找到B字符串在A字符串中出现的所有位置。如:输入A:“Today is great day,B:“day”，返回列表[2,17]。如果没有找到,返回空列表。 12345678910111213141516171819202122import java.util.ArrayList;import java.util.List;public class Demo2 &#123; public static List findString(String input, String substring) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &gt;= 0 &amp;&amp; i &lt; input.length(); i += substring.length()) &#123; i = input.indexOf(substring, i); System.out.println(&quot;i = &quot; + i); res.add(i); &#125; return res; &#125; public static void main(String[] args) &#123; String input = &quot;Today is a great day&quot;; String substring = &quot;day&quot;; List res = findString(input, substring); System.out.println(&quot;res = &quot; + res); &#125;&#125; 写一个简易的爬虫。1)抓取百度首页保存到文件 baidu_index.html中2)并进一步解析该文件中所有的超链接输出到文件 baidu_link中,超链接用“,”分隔。 12345678910111213141516171819202122232425262728293031323334353637383940import com.sun.deploy.util.StringUtils;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.select.Elements;import java.io.FileWriter;import java.io.IOException;import java.util.ArrayList;import java.util.List;public class Demo3 &#123; private static void writeHTML() throws IOException &#123; Document document = Jsoup.connect(&quot;https://www.baidu.com&quot;).get(); String html = document.html(); FileWriter fw = new FileWriter(&quot;baidu_index.html&quot;); fw.write(html); fw.close(); &#125; private static void writeLink() throws IOException &#123; Document document = Jsoup.connect(&quot;https://www.baidu.com&quot;).get(); List&lt;String&gt; links = new ArrayList&lt;&gt;(); Elements elements = document.select(&quot;a&quot;); FileWriter fw = new FileWriter(&quot;baidu_link&quot;); for (Element element : elements) &#123; links.add(element.attributes().get(&quot;href&quot;)); String line = StringUtils.join(links, &quot;, &quot;); fw.write(line); &#125; fw.close(); &#125; public static void main(String[] args) throws IOException &#123; writeHTML(); writeLink(); &#125;&#125;","categories":[],"tags":[]},{"title":"软通动力","slug":"面试软通动力","date":"2021-08-23T16:00:00.000Z","updated":"2023-05-12T13:59:08.921Z","comments":true,"path":"2021/08/24/面试软通动力/","link":"","permalink":"https://illuca.github.io/2021/08/24/%E9%9D%A2%E8%AF%95%E8%BD%AF%E9%80%9A%E5%8A%A8%E5%8A%9B/","excerpt":"","text":"java特性有哪些封装、多态、继承 封装将类的信息隐藏起来，通过该类的方法来进行访问。适当的封装更容易理解、安全。 继承基于已经存在的一个类，增加新的方法或者重写方法或增加新的属性，产生一个新类。 多态有两种方式，基于继承实现，基于接口实现。 基于继承实现12345678910111213141516171819202122232425262728293031package 多态.基于继承的实现;abstract class Animal &#123; abstract void shout();&#125;class Dog extends Animal &#123; @Override public void shout() &#123; System.out.println(&quot;汪汪！&quot;); &#125;&#125;class Cat extends Animal &#123; @Override public void shout() &#123; System.out.println(&quot;喵喵！&quot;); &#125;&#125;public class AnimalTest &#123; public static void main(String[] args) &#123; Animal a1 = new Cat(); Animal a2 = new Dog(); a1.shout(); a2.shout(); &#125;&#125; 基于接口实现12345678910111213141516171819202122232425262728293031package 多态.基于接口的实现;interface Animal &#123; void shout();&#125;class Dog implements Animal &#123; @Override public void shout() &#123; System.out.println(&quot;汪汪！&quot;); &#125;&#125;class Cat implements Animal &#123; @Override public void shout() &#123; System.out.println(&quot;喵喵！&quot;); &#125;&#125;public class 基于接口的实现 &#123; public static void main(String[] args) &#123; Animal a1 = new Cat(); Animal a2 = new Dog(); a1.shout(); a2.shout(); &#125;&#125; 重载的规则是什么？overload函数名相同、异常相同、参数列表不同、返回值相同、修饰符 重写的规则是？override函数名、返回值、形参、修饰符都不变，函数体不同，抛出的异常必须相同或者是子类。","categories":[],"tags":[]},{"title":"全尚科技","slug":"全尚科技","date":"2021-08-22T16:00:00.000Z","updated":"2023-05-12T13:59:08.921Z","comments":true,"path":"2021/08/23/全尚科技/","link":"","permalink":"https://illuca.github.io/2021/08/23/%E5%85%A8%E5%B0%9A%E7%A7%91%E6%8A%80/","excerpt":"","text":"面试全尚科技Hashmap索引1.7到1.8的变化头插和尾插 对象的四种创建方法new、反序列化、反射、clone 反序列化 将流转化为对象 反射1234567891011Class c = Class.forName(subClassName);（1）java.lang.Class.newInstance()User user = (User)c.newInstance();// 不带参数（2）java.lang.reflect.Constructor类的newInstance()Constructor con = c.getConstructor(String.class);User user = (User) con.newInstance(“name”); 第一种只能通过默认构造器构建，而第二种可以用有参构造器。特意拿Constructor 获取构造器 定制 clonep=new Person(“小王”,”123”) p=p1，他们都指向同一个对象Person(“小王”,”123”) 而p1=p.clone()不是，他们指向不同的Person对象 只是拥有相同的属性值 如果Person内部还有引用特殊的引用对象，则需要深度克隆。实现cloneable接口，重写clone方法。 springmvc的执行流程 springmvc 的最重要组件dispatcherServlet是前端控制器，与前端打交道。 容器的核心原理 机制反射 线程池的创建sheduled、fixed、cached 计划、固定、缓存、单线程 单线程123456789101112private static void createSingleThreadPool() &#123; ExecutorService executorService = Executors.newSingleThreadExecutor(); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; executorService.execute(() -&gt; &#123; // 获取线程名称,默认格式:pool-1-thread-1 System.out.println(DateUtil.now() + &quot; &quot; + Thread.currentThread().getName() + &quot; &quot; + index); // 等待2秒 sleep(2000); &#125;); &#125; &#125; 固定设置总共3个线程 123456789101112private static void createFixedThreadPool() &#123; ExecutorService executorService = Executors.newFixedThreadPool(3); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; executorService.execute(() -&gt; &#123; // 获取线程名称,默认格式:pool-1-thread-1 System.out.println(DateUtil.now() + &quot; &quot; + Thread.currentThread().getName() + &quot; &quot; + index); // 等待2秒 sleep(2000); &#125;); &#125; &#125; 计划设置总共3个线程，并且延时3s执行，类似js里面的setTimeout 123456789101112131415private static void createScheduledThreadPool() &#123; ScheduledExecutorService executorService = Executors.newScheduledThreadPool(3); System.out.println(DateUtil.now() + &quot; 提交任务&quot;); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; executorService.schedule(() -&gt; &#123; // 获取线程名称,默认格式:pool-1-thread-1 System.out.println(DateUtil.now() + &quot; &quot; + Thread.currentThread().getName() + &quot; &quot; + index); // 等待2秒 sleep(2000); &#125;, 3, TimeUnit.SECONDS); &#125; &#125; 线程顺序执行join、锁、同步信号量 join1234567891011121314151617181920212223242526272829303132333435public class MyThread &#123; public static void main(String[] args) &#123; Thread t1 = new Thread() &#123; @Override public void run() &#123; System.out.println(&quot;t1.run&quot;); &#125; &#125;; Thread t2 = new Thread() &#123; @Override public void run() &#123; try &#123; t1.join(); System.out.println(&quot;t2.run&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; Thread t3 = new Thread() &#123; @Override public void run() &#123; try &#123; t2.join(); System.out.println(&quot;t3.run&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; t1.start(); t2.start(); t3.start(); &#125;&#125; 12345678910111213141516171819202122232425262728/** * 异步执行 与顺序形成对比 */public class ThreadNot &#123; public static void main(String[] args) &#123; Thread t1 = new Thread() &#123; @Override public void run() &#123; System.out.println(&quot;t1.run&quot;); &#125; &#125;; Thread t2 = new Thread() &#123; @Override public void run() &#123; System.out.println(&quot;t2.run&quot;); &#125; &#125;; Thread t3 = new Thread() &#123; @Override public void run() &#123; System.out.println(&quot;t3.run&quot;); &#125; &#125;; t1.start(); t2.start(); t3.start(); &#125;&#125; 同步代码块12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class UseWaitSynchronize &#123; private static Object myLock1 = new Object(); private static Object myLock2 = new Object(); public static void main(String[] args) &#123; final Thread thread1 = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (myLock1) &#123; System.out.println(&quot;产品经理规划新需求...&quot;); &#125; &#125; &#125;); final Thread thread2 = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (myLock1) &#123; synchronized (myLock2) &#123; System.out.println(&quot;开发人员开发新需求功能&quot;); myLock2.notify(); &#125; &#125; &#125; &#125;); Thread thread3 = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (myLock2) &#123; System.out.println(&quot;测试人员测试新功能&quot;); &#125; &#125; &#125;); System.out.println(&quot;早上：&quot;); System.out.println(&quot;产品经理来上班了...&quot;); System.out.println(&quot;开发人员来上班了...&quot;); System.out.println(&quot;测试人员来上班了...&quot;); thread1.start(); thread2.start(); thread3.start(); &#125;&#125; 单线程池12345678910111213141516171819202122232425262728293031323334353637383940/** * @author wwj * 通过SingleThreadExecutor让线程按顺序执行 */public class ThreadPoolDemo &#123; public static void main(String[] args) throws Exception &#123; ExecutorService executorService = Executors.newSingleThreadExecutor(); final Thread thread1 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;产品经理规划新需求&quot;); &#125; &#125;); final Thread thread2 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;开发人员开发新需求功能&quot;); &#125; &#125;); Thread thread3 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;测试人员测试新功能&quot;); &#125; &#125;); System.out.println(&quot;早上：&quot;); System.out.println(&quot;首先，产品经理规划新需求...&quot;); executorService.submit(thread1); System.out.println(&quot;然后，开发人员开发新需求功能...&quot;); executorService.submit(thread2); System.out.println(&quot;最后，测试人员测试新功能...&quot;); executorService.submit(thread3); executorService.shutdown(); &#125;&#125;","categories":[],"tags":[]},{"title":"昇星科技","slug":"面试昇星科技(算法)","date":"2021-08-22T16:00:00.000Z","updated":"2023-05-12T13:59:08.921Z","comments":true,"path":"2021/08/23/面试昇星科技(算法)/","link":"","permalink":"https://illuca.github.io/2021/08/23/%E9%9D%A2%E8%AF%95%E6%98%87%E6%98%9F%E7%A7%91%E6%8A%80(%E7%AE%97%E6%B3%95)/","excerpt":"","text":"选择排序核心是找到最小值对应的坐标，假设i是最小的 123456789101112public void selection(Comparable[] arr) &#123; int N = arr.length; for(int i=0;i&lt;N;i++) &#123; int min=i; // 假设i是最小的 for(int j=i+1;j&lt;N;j++) &#123; if(less(arr[j],arr[min])) &#123; min=j; &#125; &#125; exch(arr,min,i) // 一轮下来找到了最小的 &#125;&#125; 插入排序核心是类似抓牌，将新牌插入到有序牌中。 假设0~i是有序的，将i+1插入进去，为了整个数组，引入j 123456789public void sort(Comparable[] arr) &#123; int N=arr.length; for(int i=1;i&lt;N;i++) &#123; for(int j=i;j&gt;0 &amp;&amp; less(arr[j],arr[j-1]);j--) &#123; // j不停的往前交换，直到冲不动了，或者冲到了第一名 exch(arr,j,j-1); &#125; &#125;&#125; 因为j-1的存在，所以i从1开始 希尔排序在插入排序的基础上加入一个动态步长。 123456789101112131415public void sort(Comparable[] arr) &#123; int N=arr.length; int h=1; while(h&lt;N/3) h=3*h+1; // 1,4,13 while(h&gt;=1) &#123; // 选择排序 for(int i=h;i&lt;N;i++) &#123; for(int j=i;j&gt;=h&amp;&amp;less(arr[j],arr[j-h]);j-=h) &#123; exch(arr,j,j-h); &#125; &#125; h=h/3; &#125;&#125; 因为j-h的存在，所以j&gt;=h，i=h 快速排序核心：切分 切分的核心：把第一个当做参照物，参照物不动，老师指挥两头开始交换，直到中间两个人为止。 12345678910111213141516171819public void sort(Comparable[] arr,int low,int high) &#123; if(high&lt;=low) return; int j=partition(arr,low,high) sort(arr,low,j-1); sort(arr,j+1,high);&#125;public int partition(Comparable[] arr, int low,int high) &#123; int i=low,j=high+1; while(true) &#123; while(less(arr[++i],arr[low])) if(i==high) break; while(less(arr[low],arr[--j])) if(j==low) break; if(j&lt;=i) return; exch(arr,i,j); // 高个和矮个放到合适的位置 &#125; // 最终泾渭分明，i和j对应的身高差不多，选择j作为分割线，将参照物同学放在合适的位置 exch(arr,low,j); return j;&#125; 因为第一个参照物同学不动，所以是++i，–j，j=high+1; 二叉排序树核心：&lt;0，到左子树找，&gt;0，到右子树找； 根据键找值 1234567public Value get(Node node,Key key) &#123; if(node==null) return; int cmp = key.compareTo(node.val); if(cmp&lt;0) return get(node.left,key); else if(cmp&gt;0) return get(node.right,key); else return node.val;&#125; 123456789public Node put(Node node,Key key) &#123; if(node==null) return new Node(key); int cmp = key.compareTo(node.key); if(cmp&lt;0) node.left = put(node.left,key); else if(cmp&gt;0) node.right = put(node.right,key); return node;&#125;","categories":[],"tags":[]},{"title":"颉玛能源","slug":"面颉玛能源","date":"2021-08-19T16:00:00.000Z","updated":"2023-05-12T13:59:08.921Z","comments":true,"path":"2021/08/20/面颉玛能源/","link":"","permalink":"https://illuca.github.io/2021/08/20/%E9%9D%A2%E9%A2%89%E7%8E%9B%E8%83%BD%E6%BA%90/","excerpt":"","text":"面试颉码公司hashmap 遍历 1234Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();for(Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet())&#123; System.out.println(&quot;key = &quot; + entry.getKey() + &quot;, value = &quot; + entry.getValue())&#125; 1234567891011Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); //iterating over keys onlyfor (Integer key : map.keySet()) &#123; System.out.println(&quot;Key = &quot; + key);&#125; //iterating over values onlyfor (Integer value : map.values()) &#123; System.out.println(&quot;Value = &quot; + value);&#125; 两个hashcode一样的字符串一定相等么？问题的情景是：有一个散列表，例如HashMap，往里面添加两个字符串，如果两个字符串的hashcode一样，那么两个字符串相等么？ 不一定相等。因为可能会有哈希冲突，不相等的字符串经过计算也得到了相同的hashcode，他们处于同一个链表中。而判断字符串相等是通过equals进行判定的。 HashMap中添加数据，键基本为String类型，String重写了hashcode和equals方法。 而我们在往HashSet中添加数据时，都是键，添加的元素需要重写hashcode和equals方法，否则无法添加。并且应该保证相等的对象具有相同的散列码，即equals和hashcode需要保持一致性。","categories":[],"tags":[]},{"title":"杭州福猫","slug":"福猫","date":"2021-08-15T16:00:00.000Z","updated":"2023-05-12T13:59:08.921Z","comments":true,"path":"2021/08/16/福猫/","link":"","permalink":"https://illuca.github.io/2021/08/16/%E7%A6%8F%E7%8C%AB/","excerpt":"","text":"杭州福猫公司 vue生命周期 数据库范式 事务前端 element uiupload组件 action 和url上传方式 单页面的生命周期hook 数据库范式第一范式是指电话号码不能有手机和电话两种值，强调列的原子性。所以电话号码就应该分为两个原子列 手机电话和固定电话列 第二范式必须要有主键 第三范式普通列必须完全依赖主键 第四范式 索引解决大量多表联查方法：分成多个月，名字的时效性 单例模式 事务的特性和spring的事务传播特性ACID原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。这个是数据库事物的核心，它是数据库最基本的特性。这条特性看起来简单，但是理解起来还是比较复杂的。 它的书面定义是：数据库一致性（Database Consistency）是指事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。它分为两个方面：一致读 和 一致写一致读：事务读取数据只能从一个状态中读取，不能从2个或者2个以上状态读取。一致写：事务执行的数据变更只能基于上一个一致的状态，且只能体现在一个状态中。具体解释请认真参看并理解 知乎 如何理解数据库事务中的一致性的概念？徐志斌的回答 使用@transactional后如何回滚，传统方式如何回滚先开启@EnableTransactionManagement，后在Service中@transactional 传播行为默认的事务传播行为是Propagation.REQUIRED，也就是说：如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。思寒就是用的require 1234567891011121314@Service public class UserService2 &#123; @Autowired private UserService userService; @Transactional public void inserBatch() &#123; for (int i = 0; i &lt; 10; i++) &#123; if (i == 9) &#123; throw new RuntimeException(); &#125; userService.insert(); &#125; &#125; &#125; 这个函数插入了10次 在第九次有异常按理说前面8次应该正常执行,但是并没有 数据库中没有数据这就是最省事的 一旦整个函数中有异常 就直接回滚2. supports如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行。也就是说，该模式是否支持事务，看调用它的方法是否有事务支持。测试代码如下：UserService 12345678@Transactional(propagation = Propagation.SUPPORTS) public void insert() &#123; UserEntity user = new UserEntity(); user.setUsername(“happyjava”); user.setPassword(“123456”); userRepo.save(user); throw new RuntimeException(); &#125; UserService2 123public void insertWithoutTx() &#123; userService.insert(); &#125; 按理说insert是一个事务应该回滚 但是最终没有回滚 隔离性多个事务同时运行 可能会有 脏读 幻读 不可重复读等问题为了防止需要将事务隔离隔离方法有 默认 读-未提交: 一个事务A可以读取一个未提交的事务 读-提交 重复读: 读取时 不允许修改 序列化 读-未提交Read uncommitted读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。 那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。 例子读-提交你拿着银行卡去充游戏 看到有100万 但是你付款时发现没钱了因为你老婆把你钱那去买钻石了 例子 重复读你和同学同时去银行取同一张卡的钱 串行化隔离脏数据 旧数据 持久性（Durability）就是说任何执行成功的事务修改后的数据都要保证永久的保存在数据库系统中，能够时刻记录系统的状态，并且保证发生故障后能够恢复 多线程四种线程创建方式: Runnable接口, callable接口, futureTask 生命周期: new 就绪 阻塞 运行 Dead 异常举例常用运行时常:IOException,ArrithmeticException,NullPointerException运行时都是RuntimeException子类 一般由于逻辑引起 可以避免 可以不管它Throwable祖先 Error Exception子类Exception等于RuntimeException+非运行时","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"unsw","slug":"unsw","permalink":"https://illuca.github.io/tags/unsw/"}]}