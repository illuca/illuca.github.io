{"meta":{"title":"兰陵","subtitle":"","description":"illuca的个人博客","author":"illuca","url":"https://illuca.github.io","root":"/"},"pages":[{"title":"about","date":"2021-09-02T16:22:00.000Z","updated":"2021-09-02T16:22:09.435Z","comments":true,"path":"about/index.html","permalink":"https://illuca.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-09-02T16:38:28.000Z","updated":"2021-09-02T16:38:28.254Z","comments":true,"path":"categories/index.html","permalink":"https://illuca.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-09-02T16:38:35.000Z","updated":"2021-09-02T16:38:45.036Z","comments":true,"path":"tags/index.html","permalink":"https://illuca.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"firstpaper","slug":"firstpaper","date":"2021-09-02T15:00:46.000Z","updated":"2021-09-02T15:02:05.432Z","comments":true,"path":"2021/09/02/firstpaper/","link":"","permalink":"https://illuca.github.io/2021/09/02/firstpaper/","excerpt":"","text":"测试123public void test() &#123; System.out.println(&quot;hello,hexo!&quot;)&#125;","categories":[],"tags":[{"name":"test","slug":"test","permalink":"https://illuca.github.io/tags/test/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-09-02T13:06:09.129Z","updated":"2021-09-02T13:06:09.129Z","comments":true,"path":"2021/09/02/hello-world/","link":"","permalink":"https://illuca.github.io/2021/09/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"全尚科技","slug":"全尚科技","date":"2021-08-22T16:00:00.000Z","updated":"2021-09-03T08:03:28.470Z","comments":true,"path":"2021/08/23/全尚科技/","link":"","permalink":"https://illuca.github.io/2021/08/23/%E5%85%A8%E5%B0%9A%E7%A7%91%E6%8A%80/","excerpt":"","text":"面试全尚科技Hashmap索引1.7到1.8的变化头插和尾插 对象的四种创建方法new、反序列化、反射、clone 反序列化 将流转化为对象 反射1234567891011Class c = Class.forName(subClassName);（1）java.lang.Class.newInstance()User user = (User)c.newInstance();// 不带参数（2）java.lang.reflect.Constructor类的newInstance()Constructor con = c.getConstructor(String.class);User user = (User) con.newInstance(“name”); 第一种只能通过默认构造器构建，而第二种可以用有参构造器。特意拿Constructor 获取构造器 定制 clonep=new Person(“小王”,”123”) p=p1，他们都指向同一个对象Person(“小王”,”123”) 而p1=p.clone()不是，他们指向不同的Person对象 只是拥有相同的属性值 如果Person内部还有引用特殊的引用对象，则需要深度克隆。实现cloneable接口，重写clone方法。 springmvc的执行流程 springmvc 的最重要组件dispatcherServlet是前端控制器，与前端打交道。 容器的核心原理 机制反射 线程池的创建sheduled、fixed、cached 计划、固定、缓存、单线程 单线程123456789101112private static void createSingleThreadPool() &#123; ExecutorService executorService = Executors.newSingleThreadExecutor(); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; executorService.execute(() -&gt; &#123; // 获取线程名称,默认格式:pool-1-thread-1 System.out.println(DateUtil.now() + &quot; &quot; + Thread.currentThread().getName() + &quot; &quot; + index); // 等待2秒 sleep(2000); &#125;); &#125; &#125; 固定设置总共3个线程 123456789101112private static void createFixedThreadPool() &#123; ExecutorService executorService = Executors.newFixedThreadPool(3); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; executorService.execute(() -&gt; &#123; // 获取线程名称,默认格式:pool-1-thread-1 System.out.println(DateUtil.now() + &quot; &quot; + Thread.currentThread().getName() + &quot; &quot; + index); // 等待2秒 sleep(2000); &#125;); &#125; &#125; 计划设置总共3个线程，并且延时3s执行，类似js里面的setTimeout 123456789101112131415private static void createScheduledThreadPool() &#123; ScheduledExecutorService executorService = Executors.newScheduledThreadPool(3); System.out.println(DateUtil.now() + &quot; 提交任务&quot;); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; executorService.schedule(() -&gt; &#123; // 获取线程名称,默认格式:pool-1-thread-1 System.out.println(DateUtil.now() + &quot; &quot; + Thread.currentThread().getName() + &quot; &quot; + index); // 等待2秒 sleep(2000); &#125;, 3, TimeUnit.SECONDS); &#125; &#125; 线程顺序执行join、锁、同步信号量 join1234567891011121314151617181920212223242526272829303132333435public class MyThread &#123; public static void main(String[] args) &#123; Thread t1 = new Thread() &#123; @Override public void run() &#123; System.out.println(&quot;t1.run&quot;); &#125; &#125;; Thread t2 = new Thread() &#123; @Override public void run() &#123; try &#123; t1.join(); System.out.println(&quot;t2.run&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; Thread t3 = new Thread() &#123; @Override public void run() &#123; try &#123; t2.join(); System.out.println(&quot;t3.run&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; t1.start(); t2.start(); t3.start(); &#125;&#125; 12345678910111213141516171819202122232425262728/** * 异步执行 与顺序形成对比 */public class ThreadNot &#123; public static void main(String[] args) &#123; Thread t1 = new Thread() &#123; @Override public void run() &#123; System.out.println(&quot;t1.run&quot;); &#125; &#125;; Thread t2 = new Thread() &#123; @Override public void run() &#123; System.out.println(&quot;t2.run&quot;); &#125; &#125;; Thread t3 = new Thread() &#123; @Override public void run() &#123; System.out.println(&quot;t3.run&quot;); &#125; &#125;; t1.start(); t2.start(); t3.start(); &#125;&#125; 同步代码块12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class UseWaitSynchronize &#123; private static Object myLock1 = new Object(); private static Object myLock2 = new Object(); public static void main(String[] args) &#123; final Thread thread1 = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (myLock1) &#123; System.out.println(&quot;产品经理规划新需求...&quot;); &#125; &#125; &#125;); final Thread thread2 = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (myLock1) &#123; synchronized (myLock2) &#123; System.out.println(&quot;开发人员开发新需求功能&quot;); myLock2.notify(); &#125; &#125; &#125; &#125;); Thread thread3 = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (myLock2) &#123; System.out.println(&quot;测试人员测试新功能&quot;); &#125; &#125; &#125;); System.out.println(&quot;早上：&quot;); System.out.println(&quot;产品经理来上班了...&quot;); System.out.println(&quot;开发人员来上班了...&quot;); System.out.println(&quot;测试人员来上班了...&quot;); thread1.start(); thread2.start(); thread3.start(); &#125;&#125; 单线程池12345678910111213141516171819202122232425262728293031323334353637383940/** * @author wwj * 通过SingleThreadExecutor让线程按顺序执行 */public class ThreadPoolDemo &#123; public static void main(String[] args) throws Exception &#123; ExecutorService executorService = Executors.newSingleThreadExecutor(); final Thread thread1 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;产品经理规划新需求&quot;); &#125; &#125;); final Thread thread2 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;开发人员开发新需求功能&quot;); &#125; &#125;); Thread thread3 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;测试人员测试新功能&quot;); &#125; &#125;); System.out.println(&quot;早上：&quot;); System.out.println(&quot;首先，产品经理规划新需求...&quot;); executorService.submit(thread1); System.out.println(&quot;然后，开发人员开发新需求功能...&quot;); executorService.submit(thread2); System.out.println(&quot;最后，测试人员测试新功能...&quot;); executorService.submit(thread3); executorService.shutdown(); &#125;&#125;","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"test","slug":"test","permalink":"https://illuca.github.io/tags/test/"}]}